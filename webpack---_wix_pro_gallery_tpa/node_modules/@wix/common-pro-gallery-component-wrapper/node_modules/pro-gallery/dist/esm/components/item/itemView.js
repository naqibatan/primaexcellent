import { __assign, __extends, __rest } from "tslib";
import React from "react";
import {
  GALLERY_CONSTS,
  featureManager,
  window,
  utils,
  isEditMode,
  isPreviewMode,
} from "pro-gallery-lib";
import MagnifiedImage from "./imageWithMagnified.js";
import withSecondaryMedia from "../hoc/withSecondMedia.js";
import TextItem from "./textItem.js";
import ItemHover from "./itemHover.js";
import { changeActiveElementIfNeeded, onAnchorFocus } from "./itemHelper.js";
import { cssScrollHelper } from "../helpers/cssScrollHelper";
import {
  getOuterInfoStyle,
  getInnerInfoStyle,
  getContainerStyle,
  getImageStyle,
} from "./itemViewStyleProvider";
import VideoItemWrapper from "./videos/videoItemWrapper";
import { getCustomInfoRendererProps, getLinkParams } from "./pure";
import { getSlideAnimationClassNames } from "../gallery/proGallery/scrollLessAnimationHelper";
var ImageWithSecondMedia = withSecondaryMedia(MagnifiedImage);
var TextWithSecondMedia = withSecondaryMedia(TextItem);
var ItemView = /** @class */ (function (_super) {
  __extends(ItemView, _super);
  function ItemView(props) {
    var _this = _super.call(this, props) || this;
    _this.shouldUseDirectLink = function () {
      var directLink = _this.props.directLink;
      var _a = directLink || {},
        url = _a.url,
        target = _a.target;
      var useDirectLink = !!(
        url &&
        target &&
        _this.props.options.itemClick === "link"
      );
      var shouldUseDirectLinkOnMobile =
        _this.shouldShowHoverOnMobile() &&
        _this.isClickOnCurrentHoveredItem() &&
        useDirectLink;
      if (shouldUseDirectLinkOnMobile) {
        _this.props.actions.eventsListener(GALLERY_CONSTS.events.HOVER_SET, -1);
        return true;
      }
      if (useDirectLink && !_this.shouldShowHoverOnMobile()) {
        return true;
      }
      return false;
    };
    _this.isClickOnCurrentHoveredItem = function () {
      return (
        _this.state.isCurrentHover || // this single item was already hovered.
        _this.props.options.hoveringBehaviour ===
          GALLERY_CONSTS.infoBehaviourOnHover.NO_CHANGE
      );
    }; // all the items are always 'already' hovered
    _this.props.actions.eventsListener(
      GALLERY_CONSTS.events.ITEM_CREATED,
      _this.props
    );
    _this.init();
    _this.state = {
      isCurrentHover: false,
      itemWasHovered: false,
    };
    _this.activeElement = "";
    return _this;
  }
  //-------------------------------------------| INIT |--------------------------------------------//
  ItemView.prototype.init = function () {
    this.onItemClick = this.onItemClick.bind(this);
    this.onItemWrapperClick = this.onItemWrapperClick.bind(this);
    this.onItemInfoClick = this.onItemInfoClick.bind(this);
    this.onContainerKeyUp = this.onContainerKeyUp.bind(this);
    this.onAnchorKeyDown = this.onAnchorKeyDown.bind(this);
    this.handleItemMouseDown = this.handleItemMouseDown.bind(this);
    this.handleItemMouseUp = this.handleItemMouseUp.bind(this);
    this.setItemLoaded = this.setItemLoaded.bind(this);
    this.isHighlight = this.isHighlight.bind(this);
    this.getItemHover = this.getItemHover.bind(this);
    this.getImageItem = this.getImageItem.bind(this);
    this.getVideoItem = this.getVideoItem.bind(this);
    this.getTextItem = this.getTextItem.bind(this);
    this.getItemInner = this.getItemInner.bind(this);
    this.getItemContainerStyles = this.getItemContainerStyles.bind(this);
    this.getItemWrapperStyles = this.getItemWrapperStyles.bind(this);
    this.getItemAriaLabel = this.getItemAriaLabel.bind(this);
    this.getItemContainerClass = this.getItemContainerClass.bind(this);
    this.getItemWrapperClass = this.getItemWrapperClass.bind(this);
    this.getItemContainerTabIndex = this.getItemContainerTabIndex.bind(this);
    this.isIconTag = this.isIconTag.bind(this);
    this.onMouseEnter = this.onMouseEnter.bind(this);
    this.onMouseLeave = this.onMouseLeave.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.onBlur = this.onBlur.bind(this);
    this.checkIfCurrentHoverChanged =
      this.checkIfCurrentHoverChanged.bind(this);
  };
  //----------------------------------------| ACTIONS |-------------------------------------------//
  ItemView.prototype.setItemLoaded = function () {
    this.props.actions.eventsListener(
      GALLERY_CONSTS.events.ITEM_LOADED,
      this.props
    );
    this.setState({
      loaded: true,
    });
  };
  ItemView.prototype.isIconTag = function (tagName) {
    return (
      ["button", "i", "a", "svg", "path"].indexOf(tagName.toLowerCase()) >= 0
    );
  };
  ItemView.prototype.onMouseEnter = function () {
    if (!utils.isMobile()) {
      this.props.actions.eventsListener(
        GALLERY_CONSTS.events.HOVER_SET,
        this.props.idx
      );
    }
  };
  ItemView.prototype.onMouseLeave = function () {
    if (!utils.isMobile()) {
      this.props.actions.eventsListener(GALLERY_CONSTS.events.HOVER_SET, -1);
    }
  };
  ItemView.prototype.onFocus = function () {
    var _a;
    if (
      (_a = this.props.settings) === null || _a === void 0
        ? void 0
        : _a.isAccessible
    ) {
      this.props.actions.eventsListener(
        GALLERY_CONSTS.events.HOVER_SET,
        this.props.idx
      );
    }
    this.props.actions.eventsListener(
      GALLERY_CONSTS.events.ITEM_FOCUSED,
      this.props
    );
  };
  ItemView.prototype.onBlur = function () {
    var _a;
    if (
      (_a = this.props.settings) === null || _a === void 0
        ? void 0
        : _a.isAccessible
    ) {
      this.props.actions.eventsListener(GALLERY_CONSTS.events.HOVER_SET, -1);
    }
    this.props.actions.eventsListener(
      GALLERY_CONSTS.events.ITEM_LOST_FOCUS,
      this.props
    );
  };
  ItemView.prototype.onContainerKeyUp = function (e) {
    var clickTarget = "item-container";
    switch (e.keyCode || e.charCode) {
      case 32: //space
      case 13: //enter
        e.stopPropagation();
        this.onItemClick(e, clickTarget, false); //pressing enter or space always behaves as click on main image, even if the click is on a thumbnail
        if (this.shouldUseDirectLink()) {
          this.itemAnchor.click(); // when directLink, we want to simulate the 'enter' or 'space' press on an <a> element
        }
        return false;
      default:
        return true;
    }
  };
  ItemView.prototype.onAnchorKeyDown = function (e) {
    // Similar to "onContainerKeyUp()" expect 'shouldUseDirectLink()' part, because we are already on the <a> tag (this.itemAnchor)
    var clickTarget = "item-container";
    switch (e.keyCode || e.charCode) {
      case 32: //space
      case 13: //enter
        e.stopPropagation();
        this.onItemClick(e, clickTarget, false); //pressing enter or space always behaves as click on main image, even if the click is on a thumbnail
        return false;
      default:
        return true;
    }
  };
  ItemView.prototype.handleGalleryItemAction = function (e) {
    this.props.actions.eventsListener(
      GALLERY_CONSTS.events.ITEM_ACTION_TRIGGERED,
      this.props,
      e
    );
  };
  ItemView.prototype.onItemWrapperClick = function (e) {
    var clickTarget = "item-media";
    this.onItemClick(e, clickTarget);
  };
  ItemView.prototype.onItemInfoClick = function (e) {
    var clickTarget = "item-info";
    this.onItemClick(e, clickTarget, false);
    e.stopPropagation();
  };
  ItemView.prototype.onItemClick = function (
    e,
    clickTarget,
    shouldPreventDefault
  ) {
    if (shouldPreventDefault === void 0) {
      shouldPreventDefault = true;
    }
    if (
      utils.isFunction(utils.get(window, "galleryWixCodeApi.onItemClicked"))
    ) {
      window.galleryWixCodeApi.onItemClicked(this.props); //TODO remove after OOI is fully integrated
    }
    this.props.actions.eventsListener(
      GALLERY_CONSTS.events.ITEM_CLICKED,
      __assign(__assign({}, this.props), { clickTarget: clickTarget }),
      e
    );
    if (this.shouldUseDirectLink()) {
      return;
    }
    if (shouldPreventDefault) {
      e.preventDefault();
    }
    if (
      this.shouldShowHoverOnMobile() ||
      this.shouldShowSecondMediaOnMobile()
    ) {
      this.handleHoverClickOnMobile(e);
    } else {
      this.handleGalleryItemAction(e);
    }
  };
  ItemView.prototype.handleHoverClickOnMobile = function (e) {
    if (this.isClickOnCurrentHoveredItem()) {
      this.handleGalleryItemAction(e);
      this.props.actions.eventsListener(GALLERY_CONSTS.events.HOVER_SET, -1);
    } else {
      this.props.actions.eventsListener(
        GALLERY_CONSTS.events.HOVER_SET,
        this.props.idx
      );
    }
  };
  ItemView.prototype.handleItemMouseDown = function () {
    //check for long press
    // if (utils.isMobile()) {
    //   clearTimeout(this.longPressTimer);
    //   this.longPressTimer = setTimeout(() => {
    //     e.preventDefault(); //prevent default only after a long press (so that scroll will not break)
    //     //do something
    //   }, 500);
    // }
    return true; //make sure the default event behaviour continues
  };
  ItemView.prototype.handleItemMouseUp = function () {
    if (utils.isMobile() && this.longPressTimer) {
      clearTimeout(this.longPressTimer);
    }
    return true; //make sure the default event behaviour continues
  };
  //-----------------------------------------| UTILS |--------------------------------------------//
  ItemView.prototype.shouldShowHoverOnMobile = function () {
    if (utils.isMobile()) {
      var _a = this.props.options,
        titlePlacement = _a.titlePlacement,
        hoveringBehaviour = _a.hoveringBehaviour,
        itemClick = _a.itemClick,
        alwaysShowHover = _a.alwaysShowHover,
        previewHover = _a.previewHover,
        allowDescription = _a.allowDescription,
        allowTitle = _a.allowTitle,
        isStoreGallery = _a.isStoreGallery;
      var isNewMobileSettings = featureManager.supports.mobileSettings;
      if (
        hoveringBehaviour === GALLERY_CONSTS.infoBehaviourOnHover.NEVER_SHOW
      ) {
        return false;
      }
      if (itemClick === "nothing" && this.props.type !== "video") {
        return true;
      } else if (
        this.props.customComponents.customHoverRenderer &&
        GALLERY_CONSTS.hasHoverPlacement(titlePlacement) &&
        hoveringBehaviour !== GALLERY_CONSTS.infoBehaviourOnHover.NEVER_SHOW &&
        isNewMobileSettings &&
        (allowDescription || allowTitle || isStoreGallery)
      ) {
        return true;
      }
      if (alwaysShowHover) {
        return true;
      }
      if (isEditMode() && previewHover) {
        return true;
      }
    }
    return false;
  };
  ItemView.prototype.shouldShowSecondMediaOnMobile = function () {
    if (utils.isMobile()) {
      var itemClick = this.props.options.itemClick;
      if (itemClick === "nothing" && this.props.type !== "video") {
        return (
          this.props.options.behaviourParams.item.secondaryMedia.trigger ===
          GALLERY_CONSTS.secondaryMediaTrigger.HOVER
        );
      } else {
        return false;
      }
    }
    return false;
  };
  ItemView.prototype.isHighlight = function () {
    return (
      this.props.thumbnailHighlightId &&
      this.props.thumbnailHighlightId === this.props.id
    );
  };
  ItemView.prototype.shouldHover = function () {
    //see if this could be decided in the preset
    var options = this.props.options;
    var alwaysShowHover = options.alwaysShowHover,
      previewHover = options.previewHover,
      hoveringBehaviour = options.hoveringBehaviour,
      overlayAnimation = options.overlayAnimation;
    var _a = GALLERY_CONSTS.infoBehaviourOnHover,
      NEVER_SHOW = _a.NEVER_SHOW,
      APPEARS = _a.APPEARS;
    var NO_EFFECT = GALLERY_CONSTS.overlayAnimations.NO_EFFECT;
    if (hoveringBehaviour === NEVER_SHOW) {
      return false;
    } else if (alwaysShowHover === true) {
      return true;
    } else if (isEditMode() && previewHover) {
      return true;
    } else if (
      hoveringBehaviour === APPEARS &&
      overlayAnimation === NO_EFFECT &&
      !this.state.itemWasHovered
    ) {
      //when there is no overlayAnimation, we want to render the itemHover only on first hover and on (and not before)
      //when there is a specific overlayAnimation, to support the animation we should render the itemHover before any hover activity.
      return false;
    } else if (utils.isMobile()) {
      return this.shouldShowHoverOnMobile();
    } else {
      return true;
    }
  };
  //---------------------------------------| COMPONENTS |-----------------------------------------//
  ItemView.prototype.getItemHover = function (imageDimensions) {
    var _this = this;
    var _a = this.props,
      customComponents = _a.customComponents,
      props = __rest(_a, ["customComponents"]);
    var shouldHover = this.shouldHover();
    return (
      shouldHover &&
      React.createElement(
        ItemHover,
        __assign({}, props, {
          forceShowHover: this.simulateOverlayHover(),
          isCurrentHover: this.simulateHover(),
          imageDimensions: imageDimensions,
          itemWasHovered: this.state.itemWasHovered,
          key: "hover",
          actions: {
            handleItemMouseDown: this.handleItemMouseDown,
            handleItemMouseUp: this.handleItemMouseUp,
          },
          renderCustomInfo: customComponents.customHoverRenderer
            ? function () {
                return customComponents.customHoverRenderer(
                  getCustomInfoRendererProps(_this.props)
                );
              }
            : null,
        })
      )
    );
  };
  ItemView.prototype.getImageItem = function (imageDimensions) {
    var props = utils.pick(this.props, [
      "gotFirstScrollEvent",
      "alt",
      "title",
      "description",
      "id",
      "idx",
      "options",
      "createUrl",
      "createMagnifiedUrl",
      "settings",
      "isPrerenderMode",
      "isTransparent",
      "style",
      "hasSecondaryMedia",
      "secondaryMediaItem",
      "customComponents",
    ]);
    return React.createElement(
      ImageWithSecondMedia,
      __assign({}, props, {
        key: "imageItem",
        imageDimensions: imageDimensions,
        isThumbnail: !!this.props.thumbnailHighlightId,
        isCurrentHover: this.simulateHover(),
        itemWasHovered: this.state.itemWasHovered,
        actions: {
          handleItemMouseDown: this.handleItemMouseDown,
          handleItemMouseUp: this.handleItemMouseUp,
          setItemLoaded: this.setItemLoaded,
        },
      })
    );
  };
  ItemView.prototype.getVideoItem = function (imageDimensions, itemHover) {
    return React.createElement(
      VideoItemWrapper,
      __assign({}, this.props, {
        shouldPlay: this.props.idx === this.props.playingVideoIdx,
        key: "video" + this.props.idx,
        hover: itemHover,
        imageDimensions: imageDimensions,
        hasLink: this.itemHasLink(),
        isCurrentHover: this.simulateHover(),
        actions: __assign(__assign({}, this.props.actions), {
          setItemLoaded: this.setItemLoaded,
          handleItemMouseDown: this.handleItemMouseDown,
          handleItemMouseUp: this.handleItemMouseUp,
        }),
      })
    );
  };
  ItemView.prototype.getTextItem = function (imageDimensions) {
    var props = utils.pick(this.props, [
      "id",
      "options",
      "style",
      "html",
      "cropRatio",
      "isPrerenderMode",
      "hasSecondaryMedia",
      "secondaryMediaItem",
    ]);
    return React.createElement(
      TextWithSecondMedia,
      __assign({}, props, {
        key: "textItem",
        imageDimensions: imageDimensions,
        isCurrentHover: this.simulateHover(),
        itemWasHovered: this.state.itemWasHovered,
        actions: {
          handleItemMouseDown: this.handleItemMouseDown,
          handleItemMouseUp: this.handleItemMouseUp,
          setItemLoaded: this.setItemLoaded,
        },
      })
    );
  };
  ItemView.prototype.getItemInner = function () {
    var _a = this.props,
      type = _a.type,
      style = _a.style,
      offset = _a.offset;
    var itemInner;
    var innerWidth = style.innerWidth,
      innerHeight = style.innerHeight;
    var innerTop = offset.innerTop,
      innerLeft = offset.innerLeft;
    var itemStyles = {
      width: innerWidth,
      height: innerHeight,
      marginTop: innerTop,
      marginLeft: innerLeft,
    };
    var itemHover = null;
    if (this.shouldHover()) {
      itemHover = this.getItemHover(itemStyles);
    }
    switch (type) {
      case "dummy":
        itemInner = React.createElement("div", null);
        break;
      case "video":
        itemInner = this.getVideoItem(itemStyles, itemHover);
        break;
      case "text":
        itemInner = [this.getTextItem(itemStyles), itemHover];
        break;
      case "image":
      case "picture":
      default:
        if (this.props.isVideoPlaceholder) {
          itemInner = this.getVideoItem(itemStyles, itemHover);
        } else {
          itemInner = [this.getImageItem(itemStyles), itemHover];
        }
    }
    return itemInner;
  };
  ItemView.prototype.getRightInfoElementIfNeeded = function () {
    if (
      GALLERY_CONSTS.hasExternalRightPlacement(
        this.props.options.titlePlacement,
        this.props.idx
      )
    ) {
      return this.getExternalInfoElement(
        GALLERY_CONSTS.placements.SHOW_ON_THE_RIGHT,
        "gallery-item-right-info"
      );
    } else {
      return null;
    }
  };
  ItemView.prototype.getLeftInfoElementIfNeeded = function () {
    if (
      GALLERY_CONSTS.hasExternalLeftPlacement(
        this.props.options.titlePlacement,
        this.props.idx
      )
    ) {
      return this.getExternalInfoElement(
        GALLERY_CONSTS.placements.SHOW_ON_THE_LEFT,
        "gallery-item-left-info"
      );
    } else {
      return null;
    }
  };
  ItemView.prototype.getBottomInfoElementIfNeeded = function () {
    if (
      GALLERY_CONSTS.hasExternalBelowPlacement(
        this.props.options.titlePlacement,
        this.props.idx
      )
    ) {
      return this.getExternalInfoElement(
        GALLERY_CONSTS.placements.SHOW_BELOW,
        "gallery-item-bottom-info"
      );
    } else {
      return null;
    }
  };
  ItemView.prototype.getTopInfoElementIfNeeded = function () {
    if (
      GALLERY_CONSTS.hasExternalAbovePlacement(
        this.props.options.titlePlacement,
        this.props.idx
      )
    ) {
      return this.getExternalInfoElement(
        GALLERY_CONSTS.placements.SHOW_ABOVE,
        "gallery-item-top-info"
      );
    } else {
      return null;
    }
  };
  ItemView.prototype.getExternalInfoElement = function (
    placement,
    elementName
  ) {
    var _a = this.props,
      options = _a.options,
      customComponents = _a.customComponents,
      style = _a.style;
    if (!customComponents.customInfoRenderer) {
      return null;
    }
    var info = null;
    //if there is no url for videos and images, we will not render the itemWrapper
    //but will render the info element if exists, with the whole size of the item
    var infoHeight =
      options.textBoxHeight + (this.hasRequiredMediaUrl ? 0 : style.height);
    var infoWidth =
      style.infoWidth + (this.hasRequiredMediaUrl ? 0 : style.width);
    var itemExternalInfo = customComponents.customInfoRenderer(
      getCustomInfoRendererProps(this.props),
      placement
    );
    var overrideDeckTransition = GALLERY_CONSTS.isLayout("SLIDESHOW")(
      this.props.options
    );
    info = React.createElement(
      "div",
      {
        className:
          "gallery-item-common-info-outer " +
          getSlideAnimationClassNames(this.props, overrideDeckTransition),
        style: __assign(
          {},
          getOuterInfoStyle(
            placement,
            options,
            style.height,
            options.textBoxHeight
          )
        ),
      },
      React.createElement(
        "div",
        {
          style: getInnerInfoStyle(placement, options, infoHeight, infoWidth),
          className: "gallery-item-common-info " + elementName,
          onClick: this.onItemInfoClick,
        },
        itemExternalInfo
      )
    );
    return info;
  };
  ItemView.prototype.simulateHover = function () {
    return (
      this.state.isCurrentHover ||
      this.props.options.alwaysShowHover === true ||
      (isEditMode() && this.props.options.previewHover)
    );
  };
  ItemView.prototype.simulateOverlayHover = function () {
    return (
      this.simulateHover() ||
      this.props.options.hoveringBehaviour ===
        GALLERY_CONSTS.infoBehaviourOnHover.NO_CHANGE
    );
  };
  ItemView.prototype.itemHasLink = function () {
    var _a = this.props,
      linkData = _a.linkData,
      linkUrl = _a.linkUrl;
    var itemDoesntHaveLink =
      linkData.type === undefined && (linkUrl === undefined || linkUrl === ""); //when itemClick is 'link' but no link was added to this specific item
    return !itemDoesntHaveLink;
  };
  ItemView.prototype.getItemContainerStyles = function () {
    var _a = this.props,
      idx = _a.idx,
      activeIndex = _a.activeIndex,
      offset = _a.offset,
      style = _a.style,
      options = _a.options,
      _b = _a.settings,
      settings = _b === void 0 ? {} : _b;
    var scrollDirection = options.scrollDirection,
      imageMargin = options.imageMargin,
      isRTL = options.isRTL,
      slideAnimation = options.slideAnimation;
    var containerStyleByoptions = getContainerStyle(options);
    var itemStyles = {
      overflowY: "hidden",
      position: "absolute",
      bottom: "auto",
      margin:
        scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL
          ? imageMargin / 2 + "px"
          : 0,
    };
    var avoidInlineStyles = settings.avoidInlineStyles;
    var hideOnSSR =
      this.props.isPrerenderMode && !this.props.settings.disableSSROpacity;
    var opacityStyles = avoidInlineStyles
      ? {}
      : {
          opacity: hideOnSSR ? 0 : 1,
          display: hideOnSSR ? "none" : "block",
          transition: "opacity .2s ease",
        };
    var layoutStyles = avoidInlineStyles
      ? {}
      : {
          top: offset.top,
          left: isRTL ? "auto" : offset.left,
          right: !isRTL ? "auto" : offset.left,
          width: style.width + style.infoWidth,
          height: style.height + style.infoHeight,
        };
    var slideAnimationStyles;
    switch (slideAnimation) {
      case GALLERY_CONSTS.slideAnimations.FADE:
        slideAnimationStyles = {
          left: isRTL ? "auto" : 0,
          right: !isRTL ? "auto" : 0,
          pointerEvents: activeIndex === idx ? "auto" : "none",
          zIndex: activeIndex === idx ? 0 : 1,
        };
        break;
      case GALLERY_CONSTS.slideAnimations.DECK:
        slideAnimationStyles = {
          left: isRTL ? "auto" : 0,
          right: !isRTL ? "auto" : 0,
          pointerEvents: activeIndex === idx ? "auto" : "none",
          zIndex: Math.sign(activeIndex - idx),
        };
        break;
      default:
        slideAnimationStyles = {};
    }
    var transitionStyles =
      this.state.loaded && (isEditMode() || isPreviewMode())
        ? {
            transition: "all .4s ease",
            transitionProperty: "top, left, width, height, opacity",
          }
        : {
            transition: "none",
          };
    var itemContainerStyles = __assign(
      __assign(
        __assign(
          __assign(
            __assign(__assign({}, itemStyles), layoutStyles),
            containerStyleByoptions
          ),
          transitionStyles
        ),
        opacityStyles
      ),
      slideAnimationStyles
    );
    return itemContainerStyles;
  };
  ItemView.prototype.getItemWrapperStyles = function () {
    var _a = this.props,
      createUrl = _a.createUrl,
      options = _a.options,
      style = _a.style,
      type = _a.type;
    var height = style.height,
      width = style.width;
    var styles = {};
    if (type === "text") {
      styles.backgroundColor =
        options.cubeType !== "fit" ? "transparent" : "inherit";
    } else {
      styles.backgroundColor =
        (options.cubeType !== "fit" ? style.bgColor : "inherit") ||
        "transparent";
    }
    if (
      options.imageHoverAnimation ===
      GALLERY_CONSTS.imageHoverAnimations.MAIN_COLOR
    ) {
      styles.background =
        "url(" +
        createUrl(
          GALLERY_CONSTS.urlSizes.PIXEL,
          GALLERY_CONSTS.urlTypes.HIGH_RES
        ) +
        ")";
    }
    styles.height = height + "px";
    styles.width = width + "px";
    styles.margin = -options.itemBorderWidth + "px";
    return styles;
  };
  ItemView.prototype.getItemAriaLabel = function () {
    var _a = this.props,
      type = _a.type,
      alt = _a.alt,
      htmlContent = _a.htmlContent,
      options = _a.options;
    var mapTypeToLabel = {
      dummy: "",
      text: htmlContent,
      video: alt || "",
      image: alt || "",
    };
    var label = mapTypeToLabel[type];
    return label + (options.isStoreGallery ? ", Buy Now" : "");
  };
  ItemView.prototype.isItemClickable = function (options) {
    var itemDoesntHaveLink = !this.itemHasLink(); //when itemClick is 'link' but no link was added to this specific item
    return options.itemClick === GALLERY_CONSTS.itemClick.NOTHING ||
      (options.itemClick === GALLERY_CONSTS.itemClick.LINK &&
        itemDoesntHaveLink)
      ? false
      : true;
  };
  ItemView.prototype.getItemContainerClass = function () {
    var options = this.props.options;
    var imagePlacementAnimation = options.imagePlacementAnimation;
    var overlayAnimation = options.overlayAnimation;
    var imageHoverAnimation = options.imageHoverAnimation;
    var isHovered = this.simulateHover();
    var classNames = {
      "gallery-item-container": true,
      "item-container-regular": !isHovered,
      "item-container-hover": isHovered,
      "has-custom-focus": true,
      visible: true,
      "pro-gallery-highlight": this.isHighlight(),
      clickable: this.isItemClickable(options),
      "simulate-hover": this.simulateHover(),
      "hide-hover": !this.simulateHover() && utils.isMobile(),
      "invert-hover":
        options.hoveringBehaviour ===
        GALLERY_CONSTS.infoBehaviourOnHover.DISAPPEARS,
      //animations
      "animation-slide":
        imagePlacementAnimation ===
        GALLERY_CONSTS.imagePlacementAnimations.SLIDE,
      //overlay animations
      "hover-animation-fade-in":
        overlayAnimation === GALLERY_CONSTS.overlayAnimations.FADE_IN,
      "hover-animation-expand":
        overlayAnimation === GALLERY_CONSTS.overlayAnimations.EXPAND,
      "hover-animation-slide-up":
        overlayAnimation === GALLERY_CONSTS.overlayAnimations.SLIDE_UP,
      "hover-animation-slide-right":
        overlayAnimation === GALLERY_CONSTS.overlayAnimations.SLIDE_RIGHT,
      "hover-animation-slide-down":
        overlayAnimation === GALLERY_CONSTS.overlayAnimations.SLIDE_DOWN,
      "hover-animation-slide-left":
        overlayAnimation === GALLERY_CONSTS.overlayAnimations.SLIDE_LEFT,
      //image hover animations
      "main-color-on-hover":
        imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.MAIN_COLOR,
      "zoom-in-on-hover":
        imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.ZOOM_IN,
      "blur-on-hover":
        imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.BLUR,
      "grayscale-on-hover":
        imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.GRAYSCALE,
      "shrink-on-hover":
        imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.SHRINK,
      "invert-on-hover":
        imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.INVERT,
      "color-in-on-hover":
        imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.COLOR_IN,
      "darkened-on-hover":
        imageHoverAnimation === GALLERY_CONSTS.imageHoverAnimations.DARKENED,
      "pro-gallery-mobile-indicator": utils.isMobile(),
    };
    var strClass = Object.entries(classNames)
      .map(function (_a) {
        var classname = _a[0],
          isNeeded = _a[1];
        return isNeeded ? classname : false;
      })
      .filter(Boolean)
      .join(" ");
    return strClass;
  };
  ItemView.prototype.getItemWrapperClass = function () {
    var _a = this.props,
      options = _a.options,
      type = _a.type;
    var classes = ["gallery-item-wrapper", "visible"];
    if (options.cubeImages) {
      classes.push("cube-type-" + options.cubeType);
    }
    if (type === "text") {
      classes.push("gallery-item-wrapper-text");
    }
    classes.push(getSlideAnimationClassNames(this.props));
    return classes.join(" ");
  };
  ItemView.prototype.getItemContainerTabIndex = function () {
    var tabIndex = this.isHighlight()
      ? utils.getTabIndex("currentThumbnail")
      : this.props.activeIndex === this.props.idx
      ? utils.getTabIndex("currentGalleryItem")
      : -1;
    return tabIndex;
  };
  //-----------------------------------------| REACT |--------------------------------------------//
  ItemView.prototype.componentDidMount = function () {
    if (utils.isMobile() && typeof React.initializeTouchEvents === "function") {
      try {
        React.initializeTouchEvents(true);
      } catch (e) {
        console.error(e);
      }
    }
    window.addEventListener(
      "current_hover_change",
      this.checkIfCurrentHoverChanged
    );
  };
  ItemView.prototype.componentWillUnmount = function () {
    clearTimeout(this.itemLoadedTimeout);
    window.removeEventListener(
      "current_hover_change",
      this.checkIfCurrentHoverChanged
    );
  };
  ItemView.prototype.componentDidUpdate = function (prevProps) {
    changeActiveElementIfNeeded({
      prevProps: prevProps,
      currentProps: this.props,
      itemContainer: this.itemContainer,
    });
  };
  ItemView.prototype.checkIfCurrentHoverChanged = function (e) {
    if (e.galleryId === this.props.galleryId) {
      if (!this.state.isCurrentHover && e.currentHoverIdx === this.props.idx) {
        this.setState({
          isCurrentHover: true,
          itemWasHovered: true,
        });
      } else if (
        this.state.isCurrentHover &&
        e.currentHoverIdx !== this.props.idx
      ) {
        this.setState({
          isCurrentHover: false,
        });
      }
    }
  };
  ItemView.prototype.onContextMenu = function (e) {
    if (!utils.isDev() && !this.props.options.allowContextMenu) {
      e.preventDefault(e);
    }
  };
  ItemView.prototype.getItemAriaRole = function () {
    switch (this.props.options.itemClick) {
      case "expand":
      case "fullscreen":
        return "button";
      case "link":
        return "link";
      default:
        return "";
    }
  };
  ItemView.prototype.composeItem = function () {
    var _this = this;
    var _a;
    var _b = this.props,
      photoId = _b.photoId,
      id = _b.id,
      hash = _b.hash,
      idx = _b.idx,
      options = _b.options,
      type = _b.type,
      url = _b.url;
    //if (there is an url for video items and image items) OR text item (text item do not use media url)
    this.hasRequiredMediaUrl = url || type === "text";
    //if titlePlacement !== SHOW_ON_HOVER and !this.hasRequiredMediaUrl, we will NOT render the itemWrapper (but will render the info element with the whole size of the item)
    var isItemWrapperEmpty =
      options.titlePlacement !== GALLERY_CONSTS.placements.SHOW_ON_HOVER &&
      !this.hasRequiredMediaUrl;
    var innerDiv = React.createElement(
      "div",
      {
        className: this.getItemContainerClass(),
        onContextMenu: function (e) {
          return _this.onContextMenu(e);
        },
        id: cssScrollHelper.getSellectorDomId(this.props),
        ref: function (e) {
          return (_this.itemContainer = e);
        },
        onMouseEnter: this.onMouseEnter,
        onMouseLeave: this.onMouseLeave,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        tabIndex: this.getItemContainerTabIndex(),
        "aria-label": this.getItemAriaLabel(),
        "data-hash": hash,
        "data-id": photoId,
        "data-idx": idx,
        role: this.getItemAriaRole(),
        "data-hook": "item-container",
        key: "item-container-" + id,
        style: this.getItemContainerStyles(),
        onKeyUp: this.onContainerKeyUp,
        onClick: this.onItemWrapperClick,
      },
      this.getTopInfoElementIfNeeded(),
      this.getLeftInfoElementIfNeeded(),
      React.createElement(
        "div",
        {
          style: __assign(
            __assign(
              __assign({}, getImageStyle(this.props.options)),
              GALLERY_CONSTS.hasExternalRightPlacement(
                this.props.options.titlePlacement,
                this.props.idx
              ) && { float: "left" }
            ),
            GALLERY_CONSTS.hasExternalLeftPlacement(
              this.props.options.titlePlacement,
              this.props.idx
            ) && { float: "right" }
          ),
        },
        !isItemWrapperEmpty &&
          React.createElement(
            "div",
            {
              "data-hook": "item-wrapper",
              className: this.getItemWrapperClass(),
              key: "item-wrapper-" + id,
              id: "item-wrapper-" + id,
              style: this.getItemWrapperStyles(),
            },
            this.getItemInner()
          )
      ),
      this.getRightInfoElementIfNeeded(),
      this.getBottomInfoElementIfNeeded()
    );
    var handleKeyDown = function (e) {
      /* Relvenat only for Screen-Reader case:
            Screen-Reader ignores the tabIdex={-1} and therefore stops and focuses on the <a> tag keyDown event,
            so it will not go deeper to the item-container keyDown event.
            */
      _this.onAnchorKeyDown(e);
    };
    var handleFocus = function () {
      onAnchorFocus({
        itemAnchor: _this.itemAnchor,
        enableExperimentalFeatures: _this.props.enableExperimentalFeatures,
        itemContainer: _this.itemContainer,
      });
    };
    var linkParams = getLinkParams(this.props);
    var elementProps = {
      ref: function (e) {
        return (_this.itemAnchor = e);
      },
      "data-id": photoId,
      className: "item-link-wrapper",
      "data-idx": idx,
      "data-hook": "item-link-wrapper",
      onFocus: handleFocus,
      tabIndex: -1,
      onKeyDown: handleKeyDown,
    };
    if (
      ((_a =
        linkParams === null || linkParams === void 0
          ? void 0
          : linkParams.href) === null || _a === void 0
        ? void 0
        : _a.length) > 0
    ) {
      return React.createElement(
        "a",
        __assign(
          { key: "item-container-link-" + id },
          elementProps,
          linkParams
        ),
        innerDiv
      );
    } else {
      return React.createElement(
        "div",
        __assign({ key: "item-container-div-" + id }, elementProps),
        innerDiv
      );
    }
  };
  //-----------------------------------------| RENDER |--------------------------------------------//
  ItemView.prototype.render = function () {
    return this.composeItem();
  };
  return ItemView;
})(React.Component);
export default ItemView;
/* eslint-enable prettier/prettier */
//# sourceMappingURL=itemView.js.map

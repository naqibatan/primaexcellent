import { __assign, __awaiter, __extends, __generator } from "tslib";
import React from "react";
import {
  GALLERY_CONSTS,
  window,
  utils,
  isEditMode,
  isPreviewMode,
} from "pro-gallery-lib";
import GroupView from "../../group/groupView.js";
import GalleryDebugMessage from "./galleryDebugMessage.js";
import PlayIcon from "../../svgs/components/play";
import PauseIcon from "../../svgs/components/pause";
import NavigationPanel, {
  getCustomNavigationPanelInlineStyles,
} from "./navigationPanel";
import { getItemsInViewportOrMarginByActiveGroup } from "../../helpers/virtualization";
import { NavigationArrows } from "./navigationArrows.js";
import { shouldRenderNavArrows } from "../../helpers/navigationArrowUtils.js";
import { toggleScrollLessAnimation } from "./scrollLessAnimationHelper";
var SKIP_SLIDES_MULTIPLIER = 1.5;
function getDirection(code) {
  var reverse = [33, 37, 38];
  var direct = [32, 34, 39, 40];
  if (reverse.includes(code)) return -1;
  else if (direct.includes(code)) return 1;
  throw new Error("no direction is defined for charCode: " + code);
}
var SlideshowView = /** @class */ (function (_super) {
  __extends(SlideshowView, _super);
  function SlideshowView(props) {
    var _this = _super.call(this, props) || this;
    _this.autoScrollToNextItem = function () {
      if (!isEditMode() && (_this.props.isInViewport || isPreviewMode())) {
        var options = _this.props.options;
        var direction = options.isRTL ? -1 : 1;
        if (
          options.autoSlideshowType ===
          GALLERY_CONSTS.autoSlideshowTypes.CONTINUOUS
        ) {
          _this._next({
            direction: direction,
            isAutoTrigger: true,
            isContinuousScrolling: true,
          });
        } else if (
          options.autoSlideshowType ===
          GALLERY_CONSTS.autoSlideshowTypes.INTERVAL
        ) {
          _this._next({
            direction: direction,
            isAutoTrigger: true,
            scrollDuration: 800,
          });
        }
      }
    };
    _this.getCustomNavigationPanel = function () {
      var _a;
      if (
        typeof ((_a = _this.props.customComponents) === null || _a === void 0
          ? void 0
          : _a.EXPERIMENTAL_customNavigationPanelRenderer) === "function"
      ) {
        return _this.props.customComponents
          .EXPERIMENTAL_customNavigationPanelRenderer;
      } else {
        return false;
      }
    };
    _this.createOrGetCustomNavigationPanelAPI = function () {
      var isRTL = _this.props.options.isRTL;
      return (
        _this.navigationPanelAPI ||
        (_this.navigationPanelAPI = {
          next: function () {
            return _this.next({
              scrollDuration: 400,
              isKeyboardNavigation: false,
              isAutoTrigger: false,
              avoidIndividualNavigation: false,
              isContinuousScrolling: false,
              direction: isRTL ? -1 : 1,
            });
          },
          back: function () {
            return _this.next({
              scrollDuration: 400,
              isKeyboardNavigation: false,
              isAutoTrigger: false,
              avoidIndividualNavigation: false,
              isContinuousScrolling: false,
              direction: isRTL ? 1 : -1,
            });
          },
          isAbleToNavigateNext: function () {
            return isRTL
              ? !_this.state.hideLeftArrow
              : !_this.state.hideRightArrow;
          },
          isAbleToNavigateBack: function () {
            return isRTL
              ? !_this.state.hideRightArrow
              : !_this.state.hideLeftArrow;
          },
          getActiveItemIndex: function () {
            return _this.state.activeIndex;
          },
          triggerItemAction: function (e, _a) {
            var _b = _a === void 0 ? {} : _a,
              _c = _b.itemIndex,
              itemIndex = _c === void 0 ? _this.state.activeIndex : _c;
            var galleryConfig = _this.createGalleryConfig();
            var item =
              _this.props.galleryStructure.galleryItems[
                itemIndex % _this.props.totalItemsCount
              ];
            var props =
              item === null || item === void 0
                ? void 0
                : item.renderProps(
                    __assign(__assign({}, galleryConfig), { visible: true })
                  );
            _this.props.actions.eventsListener(
              GALLERY_CONSTS.events.ITEM_ACTION_TRIGGERED,
              props,
              e
            );
          },
          // nextGroup,
          // previousItem,
          // previousGroup,
          toIndex: function (itemIdx) {
            return _this.scrollToIndex({
              itemIdx: itemIdx,
              scrollDuration: 400,
              isRTL: isRTL,
            });
          },
          // getCurrentActiveItemIndex,
          // getCurrentActiveGroupIndex,
          assignIndexChangeCallback: function (func) {
            _this.navigationPanelCallbackOnIndexChange = func;
          },
        })
      );
    };
    _this.navigationPanelCallbackOnIndexChange = function () {};
    _this.scrollToThumbnail = _this.scrollToThumbnail.bind(_this);
    _this.clearAutoSlideshowInterval =
      _this.clearAutoSlideshowInterval.bind(_this);
    _this.onFocus = _this.onFocus.bind(_this);
    _this.onBlur = _this.onBlur.bind(_this);
    _this.onAutoSlideShowButtonClick =
      _this.onAutoSlideShowButtonClick.bind(_this);
    _this.startAutoSlideshowIfNeeded =
      _this.startAutoSlideshowIfNeeded.bind(_this);
    _this.updateAutoSlideShowState = _this.updateAutoSlideShowState.bind(_this);
    _this.canStartAutoSlideshow = _this.canStartAutoSlideshow.bind(_this);
    _this.handleSlideshowKeyPress = _this.handleSlideshowKeyPress.bind(_this);
    _this.onAutoSlideshowAutoPlayKeyPress =
      _this.onAutoSlideshowAutoPlayKeyPress.bind(_this);
    _this.setCurrentItemByScroll = _this.setCurrentItemByScroll.bind(_this);
    _this._setCurrentItemByScroll = utils
      .throttle(_this.setCurrentItemByScroll, 600)
      .bind(_this);
    _this._next = utils
      .throttle(
        _this.nextWithEffects.bind(_this),
        props.isScrollLessGallery ? 600 : 400
      )
      .bind(_this);
    _this._next = utils.throttle(_this.next.bind(_this), 400).bind(_this);
    _this.state = {
      activeIndex: props.activeIndex || 0,
      isInView: true,
      pauseAutoSlideshowClicked: false,
      hideLeftArrow: !props.options.isRTL,
      hideRightArrow: props.options.isRTL,
      shouldBlockAutoSlideshow: false,
      isInFocus: false,
    };
    _this.lastCurrentItem = undefined;
    _this.shouldCreateSlideShowPlayButton = false;
    _this.skipFromSlide = Math.round(
      _this.props.totalItemsCount * SKIP_SLIDES_MULTIPLIER
    ); // Used in infinite loop
    return _this;
  }
  SlideshowView.prototype.isFirstItem = function () {
    return this.state.activeIndex === 0;
  };
  SlideshowView.prototype.isScrollStart = function () {
    var slideAnimation = this.props.options.slideAnimation;
    if (
      slideAnimation !== GALLERY_CONSTS.slideAnimations.SCROLL ||
      !this.scrollElement
    ) {
      return false;
    }
    return this.scrollPosition() <= 1;
  };
  SlideshowView.prototype.isScrollEnd = function () {
    var _a = this.props.options,
      slideshowLoop = _a.slideshowLoop,
      slideAnimation = _a.slideAnimation;
    if (
      slideshowLoop ||
      slideAnimation === GALLERY_CONSTS.slideAnimations.FADE ||
      slideAnimation === GALLERY_CONSTS.slideAnimations.DECK
    ) {
      return false;
    }
    return (
      this.isAllItemsLoaded() &&
      this.scrollPositionAtTheAndOfTheGallery() >=
        Math.floor(this.getScrollElementWidth())
    );
  };
  SlideshowView.prototype.isAllItemsLoaded = function () {
    var _a = this.props,
      totalItemsCount = _a.totalItemsCount,
      getVisibleItems = _a.getVisibleItems,
      galleryStructure = _a.galleryStructure,
      container = _a.container;
    var visibleItemsCount = getVisibleItems(
      galleryStructure.galleryItems,
      container
    ).length;
    return visibleItemsCount >= totalItemsCount;
  };
  SlideshowView.prototype.getScrollElementWidth = function () {
    var galleryStructure = this.props.galleryStructure;
    var imageMargin = this.props.options.imageMargin;
    return galleryStructure.width - imageMargin / 2;
  };
  SlideshowView.prototype.isFirstItemFullyVisible = function () {
    return !this.props.options.slideshowLoop && this.isScrollStart();
  };
  SlideshowView.prototype.isLastItemFullyVisible = function () {
    return !this.props.options.slideshowLoop && this.isScrollEnd();
  };
  SlideshowView.prototype.isLastItem = function () {
    return (
      !this.props.options.slideshowLoop &&
      this.state.activeIndex >= this.props.totalItemsCount - 1
    );
  };
  //__________________________________Slide show loop functions_____________________________________________
  //__________________________________end of slide show loop functions__________________________
  SlideshowView.prototype.shouldBlockNext = function (_a) {
    var scrollingUpTheGallery = _a.scrollingUpTheGallery;
    return (
      (scrollingUpTheGallery && this.isLastItem()) ||
      (!scrollingUpTheGallery && this.isFirstItem())
    );
  };
  SlideshowView.prototype.shouldNotAllowScroll = function (_a) {
    var scrollingUpTheGallery = _a.scrollingUpTheGallery;
    return (
      (scrollingUpTheGallery && this.isLastItemFullyVisible()) ||
      (!scrollingUpTheGallery && this.isFirstItemFullyVisible())
    );
  };
  SlideshowView.prototype.nextWithEffects = function (props) {
    return __awaiter(this, void 0, void 0, function () {
      var nextItem, skipToSlide_1;
      var _this = this;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4 /*yield*/, this.next(props)];
          case 1:
            nextItem = _a.sent();
            if (
              this.props.options.groupSize === 1 &&
              this.props.isScrollLessGallery &&
              nextItem >= this.skipFromSlide
            ) {
              skipToSlide_1 = this.skipFromSlide - this.props.totalItemsCount;
              toggleScrollLessAnimation(function () {
                return _this.onScrollToItemOrGroup(skipToSlide_1, false);
              });
            }
            return [2 /*return*/];
        }
      });
    });
  };
  SlideshowView.prototype.next = function (_a) {
    var _b;
    var direction = _a.direction,
      isAutoTrigger = _a.isAutoTrigger,
      scrollDuration = _a.scrollDuration,
      _c = _a.isKeyboardNavigation,
      isKeyboardNavigation = _c === void 0 ? false : _c,
      _d = _a.isContinuousScrolling,
      isContinuousScrolling = _d === void 0 ? false : _d;
    return __awaiter(this, void 0, void 0, function () {
      var scrollingUpTheGallery,
        activeElement,
        galleryItemIsFocused,
        avoidIndividualNavigation,
        ignoreScrollPosition;
      return __generator(this, function (_e) {
        scrollingUpTheGallery = this.props.options.isRTL
          ? direction <= -1
          : direction >= 1;
        if (
          this.shouldBlockNext({ scrollingUpTheGallery: scrollingUpTheGallery })
        ) {
          this.clearAutoSlideshowInterval();
          return [2 /*return*/];
        }
        direction *= this.props.options.isRTL ? -1 : 1;
        activeElement = document.activeElement;
        galleryItemIsFocused =
          activeElement.className &&
          activeElement.className.includes("gallery-item-container");
        avoidIndividualNavigation =
          !isKeyboardNavigation ||
          !(
            ((_b = this.props.settings) === null || _b === void 0
              ? void 0
              : _b.isAccessible) && galleryItemIsFocused
          );
        ignoreScrollPosition = false;
        if (
          this.props.options.slideAnimation !==
          GALLERY_CONSTS.slideAnimations.SCROLL
        ) {
          scrollDuration = 0;
          ignoreScrollPosition = true;
        }
        this.removeArrowsIfNeeded();
        if (avoidIndividualNavigation && this.props.options.groupSize > 1) {
          return [
            2 /*return*/,
            this.nextGroup({
              direction: direction,
              scrollDuration: scrollDuration,
              isContinuousScrolling: isContinuousScrolling,
              scrollingUpTheGallery: scrollingUpTheGallery,
            }),
          ]; //if its not in accessibility that requieres individual nav and we are in a horizontal(this file) collage(layout 0) - use group navigation
        } else {
          if (
            avoidIndividualNavigation &&
            GALLERY_CONSTS.isLayout("GRID")(this.props.options) &&
            this.props.options.numberOfImagesPerCol
          ) {
            direction *= this.props.options.numberOfImagesPerCol;
          }
          return [
            2 /*return*/,
            this.nextItem({
              direction: direction,
              isAutoTrigger: isAutoTrigger,
              scrollDuration: scrollDuration,
              avoidIndividualNavigation: avoidIndividualNavigation,
              ignoreScrollPosition: ignoreScrollPosition,
              isContinuousScrolling: isContinuousScrolling,
              scrollingUpTheGallery: scrollingUpTheGallery,
            }),
          ];
        }
        return [2 /*return*/];
      });
    });
  };
  SlideshowView.prototype.getNextItemOrGroupToScrollTo = function (
    initiator,
    direction,
    ignoreScrollPosition,
    avoidIndividualNavigation,
    isAutoTrigger
  ) {
    this.isSliding = true;
    var nextIndex;
    if (
      initiator === "nextGroup" ||
      (initiator === "nextItem" &&
        !ignoreScrollPosition &&
        avoidIndividualNavigation &&
        !(this.props.options.groupSize > 1))
    ) {
      var key = initiator === "nextGroup" ? "groups" : "galleryItems";
      nextIndex = this.getCenteredItemOrGroupIdxByScroll(key) + direction;
    } else if (initiator === "nextItem") {
      if (ignoreScrollPosition || !isAutoTrigger) {
        nextIndex = this.state.activeIndex;
      } else {
        nextIndex = this.setCurrentItemByScroll();
      }
      nextIndex += direction;
      if (!this.props.options.slideshowLoop) {
        nextIndex = Math.min(
          this.props.galleryStructure.items.length - 1,
          nextIndex
        );
        nextIndex = Math.max(0, nextIndex);
      }
    }
    this.isAutoScrolling = true;
    return nextIndex;
  };
  SlideshowView.prototype.nextItem = function (_a) {
    var direction = _a.direction,
      isAutoTrigger = _a.isAutoTrigger,
      scrollDuration = _a.scrollDuration,
      avoidIndividualNavigation = _a.avoidIndividualNavigation,
      ignoreScrollPosition = _a.ignoreScrollPosition,
      isContinuousScrolling = _a.isContinuousScrolling,
      scrollingUpTheGallery = _a.scrollingUpTheGallery;
    return __awaiter(this, void 0, void 0, function () {
      var nextItem, itemToScroll, skipToSlide, e_1;
      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            if (this.isSliding) {
              return [2 /*return*/];
            }
            nextItem = this.getNextItemOrGroupToScrollTo(
              "nextItem",
              direction,
              ignoreScrollPosition,
              avoidIndividualNavigation,
              isAutoTrigger
            );
            _b.label = 1;
          case 1:
            _b.trys.push([1, 5, , 6]);
            itemToScroll = ignoreScrollPosition ? 0 : nextItem;
            return [
              4 /*yield*/,
              this.scrollToItemOrGroup(
                this.props.actions.scrollToItem,
                itemToScroll,
                isContinuousScrolling,
                scrollDuration,
                scrollingUpTheGallery
              ),
            ];
          case 2:
            _b.sent();
            if (
              !(
                this.props.options.groupSize === 1 &&
                !this.props.isScrollLessGallery
              )
            )
              return [3 /*break*/, 4];
            skipToSlide = this.skipFromSlide - this.props.totalItemsCount;
            if (!(nextItem >= this.skipFromSlide)) return [3 /*break*/, 4];
            nextItem = skipToSlide;
            return [4 /*yield*/, this.props.actions.scrollToItem(nextItem)];
          case 3:
            _b.sent();
            _b.label = 4;
          case 4:
            this.onScrollToItemOrGroup(nextItem, isContinuousScrolling);
            if (ignoreScrollPosition) {
              this.props.getMoreItemsIfNeeded(
                this.props.galleryStructure.galleryItems[nextItem].offset.left
              );
              this.props.setGotFirstScrollIfNeeded();
            }
            return [2 /*return*/, nextItem];
          case 5:
            e_1 = _b.sent();
            this.onThrowScrollError("Cannot proceed to the next Item", e_1);
            return [3 /*break*/, 6];
          case 6:
            return [2 /*return*/];
        }
      });
    });
  };
  SlideshowView.prototype.nextGroup = function (_a) {
    var direction = _a.direction,
      scrollDuration = _a.scrollDuration,
      _b = _a.isContinuousScrolling,
      isContinuousScrolling = _b === void 0 ? false : _b,
      scrollingUpTheGallery = _a.scrollingUpTheGallery;
    return __awaiter(this, void 0, void 0, function () {
      var nextGroup, nextItem, e_2;
      return __generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            if (this.isSliding) {
              return [2 /*return*/];
            }
            nextGroup = this.getNextItemOrGroupToScrollTo(
              "nextGroup",
              direction
            );
            _c.label = 1;
          case 1:
            _c.trys.push([1, 3, , 4]);
            return [
              4 /*yield*/,
              this.scrollToItemOrGroup(
                this.props.actions.scrollToGroup,
                nextGroup,
                isContinuousScrolling,
                scrollDuration,
                scrollingUpTheGallery
              ),
            ];
          case 2:
            _c.sent();
            nextItem =
              this.getCenteredItemOrGroupIdxByScroll("galleryItems") +
              direction;
            this.onScrollToItemOrGroup(nextItem, isContinuousScrolling);
            return [3 /*break*/, 4];
          case 3:
            e_2 = _c.sent();
            this.onThrowScrollError("Cannot proceed to the next Group", e_2);
            return [3 /*break*/, 4];
          case 4:
            return [2 /*return*/];
        }
      });
    });
  };
  SlideshowView.prototype.scrollToItemOrGroup = function (
    func,
    indexToScroll,
    isContinuousScrolling,
    scrollDuration,
    scrollingUpTheGallery
  ) {
    return __awaiter(this, void 0, void 0, function () {
      var shouldAllowScroll, _a, scrollMarginCorrection, _scrollDuration, _b;
      return __generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            shouldAllowScroll = !this.shouldNotAllowScroll({
              scrollingUpTheGallery: scrollingUpTheGallery,
            });
            (_a = this.getScrollParameters(scrollDuration)),
              (scrollMarginCorrection = _a.scrollMarginCorrection),
              (_scrollDuration = _a._scrollDuration);
            _b = shouldAllowScroll;
            if (!_b) return [3 /*break*/, 2];
            return [
              4 /*yield*/,
              func(
                indexToScroll,
                false,
                true,
                _scrollDuration,
                scrollMarginCorrection,
                isContinuousScrolling
              ),
            ];
          case 1:
            _b = _c.sent();
            _c.label = 2;
          case 2:
            _b;
            return [2 /*return*/];
        }
      });
    });
  };
  SlideshowView.prototype.onThrowScrollError = function (massage, e) {
    console.error(massage, e);
    this.clearAutoSlideshowInterval();
  };
  SlideshowView.prototype.onScrollToItemOrGroup = function (
    nextItem,
    isContinuousScrolling
  ) {
    var _this = this;
    utils.setStateAndLog(
      this,
      "Next Item",
      {
        activeIndex: nextItem,
      },
      function () {
        _this.onCurrentItemChanged();
        _this.isSliding = false;
        if (isContinuousScrolling) {
          _this.startAutoSlideshowIfNeeded(_this.props.options);
        }
      }
    );
  };
  SlideshowView.prototype.getScrollParameters = function (scrollDuration) {
    return {
      scrollMarginCorrection: this.getStyles().margin || 0,
      _scrollDuration:
        scrollDuration || this.props.options.scrollDuration || 400,
    };
  };
  SlideshowView.prototype.onCurrentItemChanged = function () {
    if (this.lastCurrentItem !== this.state.activeIndex) {
      this.lastCurrentItem = this.state.activeIndex;
      //this.props.actions.onCurrentItemChanged(this.state.currentIdx);
      var currentGalleryItem =
        this.props.galleryStructure.galleryItems[this.state.activeIndex];
      var item = this.props.items[this.state.activeIndex];
      if (item) {
        item.idx = this.state.activeIndex;
        item.resizedImageSrc = currentGalleryItem.createUrl(
          GALLERY_CONSTS.urlSizes.RESIZED,
          GALLERY_CONSTS.urlTypes.HIGH_RES
        );
        this.props.actions.eventsListener(
          GALLERY_CONSTS.events.CURRENT_ITEM_CHANGED,
          item
        );
      }
      this.navigationPanelCallbackOnIndexChange(this.state.activeIndex);
    }
    this.removeArrowsIfNeeded();
  };
  SlideshowView.prototype.clearAutoSlideshowInterval = function () {
    clearInterval(this.autoSlideshowInterval);
  };
  SlideshowView.prototype.canStartAutoSlideshow = function (options) {
    return options.isAutoSlideshow && !this.state.shouldBlockAutoSlideshow;
  };
  SlideshowView.prototype.startAutoSlideshowIfNeeded = function (options) {
    this.clearAutoSlideshowInterval();
    if (this.canStartAutoSlideshow(options)) {
      if (
        options.autoSlideshowType ===
          GALLERY_CONSTS.autoSlideshowTypes.CONTINUOUS &&
        options.autoSlideshowContinuousSpeed > 0
      ) {
        this.autoScrollToNextItem();
      } else if (
        options.autoSlideshowType ===
          GALLERY_CONSTS.autoSlideshowTypes.INTERVAL &&
        options.autoSlideshowInterval > 0
      ) {
        this.autoSlideshowInterval = setInterval(
          this.autoScrollToNextItem,
          options.autoSlideshowInterval * 1000
        );
      }
    }
  };
  SlideshowView.prototype.scrollToThumbnail = function (
    itemIdx,
    scrollDuration
  ) {
    //not to confuse with this.props.actions.scrollToItem. this is used to replace it only for thumbnail items
    this.props.actions.eventsListener(
      GALLERY_CONSTS.events.THUMBNAIL_CLICKED,
      this.props
    );
    this.scrollToIndex({
      itemIdx: itemIdx,
      scrollDuration: scrollDuration,
      isRTL: this.props.options.isRTL,
    });
  };
  SlideshowView.prototype.scrollToIndex = function (_a) {
    var itemIdx = _a.itemIdx,
      scrollDuration = _a.scrollDuration,
      isRTL = _a.isRTL;
    //not to confuse with this.props.actions.scrollToItem. this is used to replace it only for thumbnail items
    this.props.setGotFirstScrollIfNeeded(); //load all the images in the thumbnails bar
    var direction = isRTL
      ? this.state.activeIndex - itemIdx
      : itemIdx - this.state.activeIndex;
    return this.next({
      direction: direction,
      isAutoTrigger: false,
      scrollDuration: scrollDuration,
      isKeyboardNavigation: false,
    });
  };
  SlideshowView.prototype.handleSlideshowKeyPress = function (e) {
    e.stopPropagation();
    var relevantKeys = [32, 33, 34, 37, 38, 39, 40, 27];
    // key code -> 32=space, 37=left, 38=up, 39=right, 40=down, 27=esc
    // charCode -> , 33=page up, 34=page down
    var code = e.charCode || e.keyCode;
    if (relevantKeys.includes(code) === false) return true;
    e.preventDefault();
    var activeItemIdx = window.document.activeElement.getAttribute("data-idx");
    var shouldFocusOutOfViewComponent =
      activeItemIdx &&
      this.props.totalItemsCount - 1 === Number(activeItemIdx) &&
      Number(activeItemIdx) === this.state.activeIndex;
    if ((code === 40 && shouldFocusOutOfViewComponent) || code === 27) {
      var elementToFocus = {
        27: this.props.galleryContainerRef,
        40: this.props.outOfViewComponent,
      }[code];
      utils.focusGalleryElement(elementToFocus);
    } else {
      this._next({ direction: getDirection(code), isKeyboardNavigation: true });
    }
    return false;
  };
  SlideshowView.prototype.getCenteredItemOrGroupIdxByScroll = function (key) {
    var itemsOrGroups = this.props.galleryStructure[key];
    var centeredItemOrGroupIdx;
    var scrollPositionAtTheMiddleOfTheGallery =
      this.scrollPositionAtTheMiddleOfTheGallery();
    if (scrollPositionAtTheMiddleOfTheGallery === 0) {
      centeredItemOrGroupIdx = 0;
    } else {
      for (
        var itemOrGroup = void 0, i = 0;
        (itemOrGroup = itemsOrGroups[i]);
        i++
      ) {
        var itemOrGroupLeft =
          key === "galleryItems" ? itemOrGroup.offset.left : itemOrGroup.left;
        if (itemOrGroupLeft > scrollPositionAtTheMiddleOfTheGallery) {
          centeredItemOrGroupIdx = i - 1;
          break;
        }
      }
    }
    if (!(centeredItemOrGroupIdx >= 0)) {
      centeredItemOrGroupIdx = itemsOrGroups.length - 1;
    }
    return centeredItemOrGroupIdx;
  };
  SlideshowView.prototype.setCurrentItemByScroll = function () {
    var _this = this;
    if (utils.isVerbose()) {
      console.log("Setting current Idx by scroll", this.isAutoScrolling);
    }
    if (this.isAutoScrolling) {
      //avoid this function if the scroll was originated by us (arrows or navigationPanels)
      this.isAutoScrolling = false;
      return;
    }
    var isScrolling =
      (this.scrollElement &&
        this.scrollElement.getAttribute("data-scrolling")) === "true";
    if (isScrolling) {
      this.clearAutoSlideshowInterval();
      //while the scroll is animating, prevent the reaction to this event
      return;
    }
    this.startAutoSlideshowIfNeeded(this.props.options);
    var activeIndex = this.getCenteredItemOrGroupIdxByScroll("galleryItems");
    if (!utils.isUndefined(activeIndex)) {
      utils.setStateAndLog(
        this,
        "Set Current Item",
        {
          activeIndex: activeIndex,
        },
        function () {
          _this.onCurrentItemChanged();
        }
      );
    }
    return activeIndex;
  };
  SlideshowView.prototype.createDebugMsg = function () {
    return React.createElement(
      GalleryDebugMessage,
      __assign({}, this.props.debug)
    );
  };
  SlideshowView.prototype.createNavArrows = function () {
    var _a = this.props,
      container = _a.container,
      options = _a.options,
      customComponents = _a.customComponents,
      id = _a.id;
    var _b = this.state,
      hideLeftArrow = _b.hideLeftArrow,
      hideRightArrow = _b.hideRightArrow;
    return React.createElement(NavigationArrows, {
      container: container,
      options: options,
      customNavArrowsRenderer: customComponents.customNavArrowsRenderer,
      hideLeftArrow: hideLeftArrow,
      hideRightArrow: hideRightArrow,
      next: this._next,
      id: id,
    });
  };
  SlideshowView.prototype.getBufferedItems = function (
    galleryGroups,
    container
  ) {
    var _a;
    var _b = this,
      state = _b.state,
      props = _b.props;
    var options = props.options,
      virtualizationSettings = props.virtualizationSettings,
      getVisibleItems = props.getVisibleItems;
    var activeIndex = state.activeIndex;
    var groups = getVisibleItems(galleryGroups, container);
    var galleryWidth =
      ((_a = this.props.galleryContainerRef) === null || _a === void 0
        ? void 0
        : _a.clientWidth) ||
      container.galleryWidth ||
      0;
    return getItemsInViewportOrMarginByActiveGroup({
      groups: groups,
      activeIndex: activeIndex,
      galleryWidth: galleryWidth,
      options: options,
      virtualizationSettings: virtualizationSettings,
    });
  };
  SlideshowView.prototype.createGalleryConfig = function () {
    return {
      scrollingElement: this.props.scrollingElement,
      scroll: this.props.scroll,
      container: this.props.container,
      options: this.props.options,
      settings: this.props.settings,
      activeIndex: this.state.activeIndex,
      customComponents: this.props.customComponents,
      galleryId: this.props.id,
      gotFirstScrollEvent: this.props.gotFirstScrollEvent,
      playingVideoIdx: this.props.playingVideoIdx,
      noFollowForSEO: this.props.noFollowForSEO,
      isPrerenderMode: this.props.isPrerenderMode,
      firstUserInteractionExecuted: this.props.firstUserInteractionExecuted,
      enableExperimentalFeatures: this.props.enableExperimentalFeatures,
      actions: {
        eventsListener: this.props.actions.eventsListener,
      },
      totalItemsCount: this.props.totalItemsCount,
      totalWidth: this.props.galleryStructure.width,
    };
  };
  SlideshowView.prototype.createLayout = function () {
    var _this = this;
    var _a = this.props,
      container = _a.container,
      galleryStructure = _a.galleryStructure;
    var galleryConfig = this.createGalleryConfig();
    var renderGroups = function (column) {
      var layoutGroupView =
        !!column.galleryGroups.length &&
        _this.getBufferedItems(column.galleryGroups, container);
      if (layoutGroupView) {
        return layoutGroupView.map(function (_a) {
          var group = _a.group,
            shouldRender = _a.shouldRender;
          return group.rendered
            ? React.createElement(
                GroupView,
                __assign(
                  __assign(
                    {
                      activeIndex: _this.state.activeIndex,
                      slideAnimation: _this.props.options.slideAnimation,
                      allowLoop:
                        _this.props.options.slideshowLoop &&
                        _this.props.galleryStructure.width >
                          _this.props.container.width,
                    },
                    group.renderProps(galleryConfig)
                  ),
                  {
                    ariaHidden: group.idx > _this.skipFromSlide,
                    shouldRenderEmpty: !shouldRender,
                    container: _this.props.container,
                    key: group.idx,
                  }
                )
              )
            : false;
        });
      }
    };
    return galleryStructure.columns.map(function (column, c) {
      var columnStyle = {
        width: _this.props.isPrerenderMode ? "100%" : column.width,
        height: _this.getDimensions().height,
        overflowY: _this.props.isPrerenderMode ? "visible" : "hidden",
      };
      return React.createElement(
        "div",
        {
          "data-hook": "gallery-column",
          id: "gallery-horizontal-scroll-" + _this.props.id,
          className:
            "gallery-horizontal-scroll gallery-column hide-scrollbars " +
            (_this.props.options.isRTL ? " rtl " : " ltr ") +
            " " +
            (_this.props.options.scrollSnap ? " scroll-snap " : "") +
            " ",
          key: "column" + c,
          style: columnStyle,
        },
        React.createElement(
          "div",
          { className: "gallery-horizontal-scroll-inner" },
          renderGroups(column)
        )
      );
    });
  };
  SlideshowView.prototype.getDimensions = function () {
    var height = this.props.container.galleryHeight;
    return this.props.isPrerenderMode
      ? {
          width: "100%",
          height: height,
        }
      : {
          height: height,
          width: this.props.container.galleryWidth,
        };
  };
  SlideshowView.prototype.createGallery = function () {
    var _a;
    // When arrows are set outside of the gallery, gallery is resized (in dimensionsHelper -> getGalleryWidth) and needs to be positioned accordingly
    var galleryStyleForExternalArrows =
      this.props.options.scrollDirection ===
        GALLERY_CONSTS.scrollDirection.HORIZONTAL &&
      this.props.options.arrowsPosition ===
        GALLERY_CONSTS.arrowsPosition.OUTSIDE_GALLERY
        ? {
            overflow: "visible",
            left:
              this.props.options.arrowsSize +
              40 +
              this.props.options.imageMargin / 2,
          }
        : {};
    var mouseCursorContainerStyle = {
      display: "flex",
      justifyContent: "space-between",
    };
    var galleryDimensions = this.getDimensions();
    var galleryStyle = __assign(
      __assign(__assign({}, galleryDimensions), galleryStyleForExternalArrows),
      mouseCursorContainerStyle
    );
    return React.createElement(
      "div",
      {
        id: this.props.galleryContainerId,
        className:
          "pro-gallery inline-styles one-row hide-scrollbars " +
          (this.props.options.enableScroll ? " slider " : "") +
          ((
            (_a = this.props.settings) === null || _a === void 0
              ? void 0
              : _a.isAccessible
          )
            ? " accessible "
            : "") +
          (this.props.options.isRTL ? " rtl " : " ltr "),
        style: galleryStyle,
      },
      this.createDebugMsg(),
      this.createLayout(),
      this.createAutoSlideShowPlayButton(),
      this.createSlideShowNumbers(),
      shouldRenderNavArrows({
        options: this.props.options,
        container: this.props.container,
        isPrerenderMode: this.props.isPrerenderMode,
        galleryStructure: this.props.galleryStructure,
        customNavArrowsRenderer:
          this.props.customComponents.customNavArrowsRenderer,
      }) && this.createNavArrows()
    );
  };
  SlideshowView.prototype.onAutoSlideShowButtonClick = function () {
    var _this = this;
    this.setState(
      { pauseAutoSlideshowClicked: !this.state.pauseAutoSlideshowClicked },
      function () {
        _this.updateAutoSlideShowState(_this.props);
      }
    );
  };
  SlideshowView.prototype.isFullWidthGallery = function () {
    return this.props.container.galleryWidth >= utils.getWindowWidth() - 10;
  };
  SlideshowView.prototype.onAutoSlideshowAutoPlayKeyPress = function (e) {
    switch (e.keyCode || e.charCode) {
      case 32: //space
      case 13: //enter
        e.preventDefault();
        e.stopPropagation();
        this.onAutoSlideShowButtonClick();
        return false;
      default:
        return true;
    }
  };
  SlideshowView.prototype.calcSlideshowCounterWidth = function () {
    var totalItemsCount = this.props.totalItemsCount;
    if (totalItemsCount < 10) {
      // x/x
      return 26;
    } else if (totalItemsCount < 100) {
      // xx/xx
      return 43;
    } else if (totalItemsCount < 1000) {
      // xxx/xxx
      return 60;
    } else {
      // xxxx/xxxx or more
      return 76;
    }
  };
  SlideshowView.prototype.createAutoSlideShowPlayButton = function () {
    var _this = this;
    if (!this.shouldCreateSlideShowPlayButton) {
      return false;
    }
    var _a = this.props.options,
      galleryTextAlign = _a.galleryTextAlign,
      textBoxHeight = _a.textBoxHeight;
    var imageMargin =
      this.props.options.imageMargin / 2 + (this.isFullWidthGallery() ? 50 : 0);
    var side =
      galleryTextAlign === "right"
        ? { left: imageMargin / 2 + "px" }
        : {
            right:
              imageMargin / 2 +
              (this.props.options.allowSlideshowCounter
                ? this.calcSlideshowCounterWidth()
                : 0) +
              "px",
          };
    return React.createElement(
      "button",
      {
        className: "auto-slideshow-button",
        onClick: function () {
          _this.onAutoSlideShowButtonClick();
        },
        onKeyDown: this.onAutoSlideshowAutoPlayKeyPress,
        "data-hook": "auto-slideshow-button",
        title: "slideshow auto play",
        "aria-pressed": this.state.pauseAutoSlideshowClicked,
        tabIndex: 0,
        style: __assign(
          { top: "calc(100% - " + textBoxHeight + "px + 3px)" },
          side
        ),
      },
      this.state.pauseAutoSlideshowClicked
        ? React.createElement(PlayIcon, { width: "10px", height: "100%" })
        : React.createElement(PauseIcon, { width: "10px", height: "100%" })
    );
  };
  SlideshowView.prototype.createSlideShowNumbers = function () {
    if (!this.props.options.allowSlideshowCounter) {
      return false;
    }
    var _a = this.props,
      totalItemsCount = _a.totalItemsCount,
      _b = _a.options,
      galleryTextAlign = _b.galleryTextAlign,
      textBoxHeight = _b.textBoxHeight;
    var imageMargin =
      this.props.options.imageMargin / 2 + (this.isFullWidthGallery() ? 50 : 0);
    var leftMargin = this.shouldCreateSlideShowPlayButton
      ? imageMargin / 2 + 25
      : imageMargin / 2;
    var side =
      galleryTextAlign === "right"
        ? { left: leftMargin + "px" }
        : { right: imageMargin / 2 + "px" };
    return React.createElement(
      "div",
      {
        className: "auto-slideshow-counter",
        "data-hook": "auto-slideshow-counter",
        style: __assign(
          { top: "calc(100% - " + textBoxHeight + "px + 3px)" },
          side
        ),
      },
      React.createElement(
        "div",
        null,
        (this.state.activeIndex % totalItemsCount) + 1 + "/" + totalItemsCount
      )
    );
  };
  SlideshowView.prototype.getNavigationPanelArray = function () {
    if (!this.props.options.hasThumbnails) {
      return [false, false];
    }
    var customNavigationPanelRenderer = this.getCustomNavigationPanel();
    var navigationPanel;
    if (customNavigationPanelRenderer) {
      var _a = this.props.container,
        galleryHeight = _a.galleryHeight,
        galleryWidth = _a.galleryWidth,
        height = _a.height,
        width = _a.width;
      var galleryThumbnailsAlignment_1 =
        this.props.options.galleryThumbnailsAlignment;
      var navigationPanelPosition_1 =
        this.props.options.layoutParams.thumbnails.position;
      var customNavigationPanelInlineStyles =
        getCustomNavigationPanelInlineStyles({
          galleryHeight: galleryHeight,
          galleryWidth: galleryWidth,
          height: height,
          width: width,
          galleryThumbnailsAlignment: galleryThumbnailsAlignment_1,
          navigationPanelPosition: navigationPanelPosition_1,
        });
      navigationPanel = React.createElement(
        "div",
        {
          className: "custom-navigation-panel",
          style: customNavigationPanelInlineStyles,
        },
        customNavigationPanelRenderer(
          __assign(__assign({}, this.props), {
            activeIndex: this.state.activeIndex,
            navigationToIdxCB: this.scrollToThumbnail,
            navigationPanelAPI: this.createOrGetCustomNavigationPanelAPI(),
          })
        )
      );
    } else {
      navigationPanel = React.createElement(
        NavigationPanel,
        __assign({}, this.props, {
          activeIndex: this.state.activeIndex,
          navigationToIdxCB: this.scrollToThumbnail,
        })
      );
    }
    var navigationPanelPosition =
      this.props.options.layoutParams.thumbnails.position;
    var galleryThumbnailsAlignment =
      this.props.options.galleryThumbnailsAlignment;
    var navigationPanels = [];
    if (
      navigationPanelPosition === GALLERY_CONSTS.thumbnailsPosition.ON_GALLERY
    ) {
      navigationPanels[0] = false;
      navigationPanels[1] = navigationPanel;
      return navigationPanels;
    } else {
      //OUTSIDE_GALLERY
      switch (galleryThumbnailsAlignment) {
        case "top":
        case "left":
          navigationPanels[0] = navigationPanel;
          navigationPanels[1] = false;
          break;
        case "right":
        case "bottom":
          navigationPanels[0] = false;
          navigationPanels[1] = navigationPanel;
          break;
      }
      return navigationPanels;
    }
  };
  SlideshowView.prototype.getClassNames = function () {
    var classNames = "pro-gallery-parent-container";
    if (GALLERY_CONSTS.isLayout("SLIDER")(this.props.options)) {
      classNames += " gallery-slider";
    } else if (this.props.options.hasThumbnails) {
      classNames += " gallery-thumbnails";
    } else if (GALLERY_CONSTS.isLayout("COLUMN")(this.props.options)) {
      classNames += " gallery-columns";
    }
    return classNames;
  };
  SlideshowView.prototype.getStyles = function () {
    return {
      margin:
        -1 *
        (this.props.options.imageMargin / 2 -
          this.props.options.layoutParams.gallerySpacing),
      width: this.props.container.width,
      height: this.props.container.height,
    };
  };
  SlideshowView.prototype.getScrollPosition = function () {
    return this.scrollElement ? this.scrollPosition() : 0;
  };
  SlideshowView.prototype.scrollPositionAtTheMiddleOfTheGallery = function () {
    return this.getScrollPosition() + this.props.container.galleryWidth / 2;
  };
  SlideshowView.prototype.scrollPositionAtTheAndOfTheGallery = function () {
    return this.getScrollPosition() + this.props.container.galleryWidth;
  };
  SlideshowView.prototype.scrollPosition = function () {
    return (this.props.options.isRTL ? -1 : 1) * this.scrollElement.scrollLeft;
  };
  //-----------------------------------------| REACT |--------------------------------------------//
  SlideshowView.prototype.updateAutoSlideShowState = function (props) {
    var _this = this;
    if (props === void 0) {
      props = this.props;
    }
    var isGalleryInHover = props.isGalleryInHover,
      options = props.options,
      settings = props.settings;
    var _a = this.state,
      pauseAutoSlideshowClicked = _a.pauseAutoSlideshowClicked,
      shouldBlockAutoSlideshow = _a.shouldBlockAutoSlideshow,
      isInView = _a.isInView,
      isInFocus = _a.isInFocus;
    var shouldPauseDueToHover =
      isGalleryInHover && options.pauseAutoSlideshowOnHover;
    var shouldPauseDueToFocus =
      isInFocus &&
      (settings === null || settings === void 0
        ? void 0
        : settings.isAccessible);
    var shouldBlock =
      !isInView ||
      pauseAutoSlideshowClicked ||
      shouldPauseDueToFocus ||
      shouldPauseDueToHover;
    if (shouldBlockAutoSlideshow !== shouldBlock) {
      this.setState({ shouldBlockAutoSlideshow: shouldBlock }, function () {
        _this.startAutoSlideshowIfNeeded(options);
      });
    }
  };
  SlideshowView.prototype.onFocus = function () {
    var _this = this;
    this.setState({ isInFocus: true }, function () {
      _this.updateAutoSlideShowState(_this.props);
    });
  };
  SlideshowView.prototype.onBlur = function () {
    var _this = this;
    this.setState({ isInFocus: false }, function () {
      _this.updateAutoSlideShowState(_this.props);
    });
  };
  SlideshowView.prototype.UNSAFE_componentWillReceiveProps = function (props) {
    var _this = this;
    var _a, _b;
    var isInView =
      props.isInViewport &&
      ((_a = props.isInDisplay) !== null && _a !== void 0 ? _a : true);
    var oldIsInView =
      this.props.isInViewport &&
      ((_b = this.props.isInDisplay) !== null && _b !== void 0 ? _b : true);
    if (isInView !== oldIsInView) {
      this.setState({ isInView: isInView }, function () {
        _this.updateAutoSlideShowState(props);
      });
    } else if (this.props.isGalleryInHover !== props.isGalleryInHover) {
      this.updateAutoSlideShowState(props);
    } else if (this.props.container.scrollBase != props.container.scrollBase) {
      this.forceUpdate(function () {
        _this.startAutoSlideshowIfNeeded(props.options);
      });
    }
    if (this.props.activeIndex !== props.activeIndex) {
      utils.setStateAndLog(
        this,
        "Next Item",
        {
          activeIndex: props.activeIndex,
        },
        function () {
          _this.onCurrentItemChanged();
        }
      );
    }
    if (this.props.totalItemsCount !== props.totalItemsCount) {
      this.removeArrowsIfNeeded();
    }
    if (isEditMode() || isPreviewMode()) {
      if (
        //check that the change is related to the slideshow settings
        this.props.options.isAutoSlideshow !== props.options.isAutoSlideshow ||
        this.props.options.autoSlideshowInterval !==
          props.options.autoSlideshowInterval
      ) {
        this.startAutoSlideshowIfNeeded(props.options);
      }
    }
    this.shouldCreateSlideShowPlayButton =
      props.options.isAutoSlideshow && props.options.playButtonForAutoSlideShow;
  };
  SlideshowView.prototype.removeArrowsIfNeeded = function () {
    var isRTL = this.props.options.isRTL;
    var _a = this.state,
      hideLeftArrow = _a.hideLeftArrow,
      hideRightArrow = _a.hideRightArrow;
    var isScrollStart = this.isScrollStart();
    var isFirstItem = this.isFirstItem();
    var isScrollEnd = this.isScrollEnd();
    var isLastItem = this.isLastItem();
    var atStart = isScrollStart || isFirstItem;
    var atEnd = isScrollEnd || isLastItem;
    var nextHideLeft = (!isRTL && atStart) || (isRTL && atEnd);
    var nextHideRight = (isRTL && atStart) || (!isRTL && atEnd);
    var shouldUpdateArrowsState =
      !!nextHideLeft !== !!hideLeftArrow ||
      !!nextHideRight !== !!hideRightArrow;
    if (shouldUpdateArrowsState) {
      this.setState({
        hideLeftArrow: !!nextHideLeft,
        hideRightArrow: !!nextHideRight,
      });
    }
  };
  SlideshowView.prototype.componentDidMount = function () {
    this.scrollElement = window.document.querySelector(
      "#pro-gallery-" +
        this.props.id +
        " #gallery-horizontal-scroll-" +
        this.props.id
    );
    if (this.scrollElement) {
      this.scrollElement.addEventListener(
        "scroll",
        this._setCurrentItemByScroll
      );
    }
    if (this.state.activeIndex > 0) {
      this.props.actions.scrollToItem(this.state.activeIndex);
      this.onCurrentItemChanged();
    } else {
      this.setCurrentItemByScroll();
    }
    this.startAutoSlideshowIfNeeded(this.props.options);
  };
  SlideshowView.prototype.componentWillUnmount = function () {
    if (this.scrollElement) {
      this.scrollElement.removeEventListener(
        "scroll",
        this._setCurrentItemByScroll
      );
    }
  };
  //-----------------------------------------| RENDER |--------------------------------------------//
  SlideshowView.prototype.render = function () {
    if (utils.isVerbose()) {
      console.count("galleryView render");
      console.count("Rendering Gallery count");
      console.time("Rendering Gallery took ");
    }
    var gallery = this.createGallery();
    var navigationPanel = this.getNavigationPanelArray();
    if (utils.isVerbose()) {
      console.timeEnd("Rendering Gallery took ");
    }
    return React.createElement(
      "div",
      __assign(
        {
          className: this.getClassNames(),
          style: this.getStyles(),
          onKeyDown: this.handleSlideshowKeyPress,
        },
        utils.getAriaAttributes({
          proGalleryRole: this.props.proGalleryRole,
          proGalleryRegionLabel: this.props.proGalleryRegionLabel,
        }),
        { onFocus: this.onFocus, onBlur: this.onBlur }
      ),
      navigationPanel[0],
      gallery,
      navigationPanel[1]
    );
  };
  return SlideshowView;
})(React.Component);
export default SlideshowView;
//# sourceMappingURL=slideshowView.js.map

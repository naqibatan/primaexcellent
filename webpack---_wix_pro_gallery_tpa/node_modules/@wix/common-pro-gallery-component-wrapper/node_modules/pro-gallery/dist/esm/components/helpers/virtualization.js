import { GALLERY_CONSTS } from "pro-gallery-lib";
export function getItemsInViewportOrMarginByActiveGroup(_a) {
  var groups = _a.groups,
    options = _a.options,
    virtualizationSettings = _a.virtualizationSettings,
    galleryWidth = _a.galleryWidth,
    galleryHeight = _a.galleryHeight,
    activeIndex = _a.activeIndex;
  var _b = virtualizationSettings || {},
    _c = _b.enabled,
    enabled = _c === void 0 ? false : _c,
    _d = _b.forwardItemMargin,
    forwardItemMargin = _d === void 0 ? 3 : _d,
    _e = _b.backwardItemMargin,
    backwardItemMargin = _e === void 0 ? 3 : _e,
    _f = _b.forwardItemScrollMargin,
    forwardItemScrollMargin = _f === void 0 ? 10 : _f,
    _g = _b.backwardItemScrollMargin,
    backwardItemScrollMargin = _g === void 0 ? 10 : _g;
  var isHorizontal =
    options.scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL;
  var isScrollable =
    !isHorizontal ||
    options.slideAnimation === GALLERY_CONSTS.slideAnimations.SCROLL;
  if (!enabled) {
    return groups.map(function (group) {
      return {
        group: group,
        shouldRender: true,
      };
    });
  }
  var size = isHorizontal ? galleryWidth : galleryHeight;
  var unit = isHorizontal ? "width" : "height";
  var rightRenderBuffer = isScrollable
    ? forwardItemScrollMargin
    : forwardItemMargin;
  var leftRenderBuffer = isScrollable
    ? backwardItemScrollMargin
    : backwardItemMargin;
  var activeGroupIndex = groups.findIndex(function (group) {
    var _a, _b;
    var items = group.items;
    var first = items[0];
    var last = items[items.length - 1];
    var firstIndex =
      (_a = first.idx) !== null && _a !== void 0 ? _a : first.fullscreenIdx;
    var lastIndex =
      (_b = last.idx) !== null && _b !== void 0 ? _b : last.fullscreenIdx;
    return firstIndex <= activeIndex && lastIndex >= activeIndex;
  });
  var activeGroup = groups[activeGroupIndex];
  var activeGroupPrecOfScreen = activeGroup[unit] / size;
  var accoumilatedRightMargin = activeGroupPrecOfScreen;
  var accoumilatedLeftMargin = activeGroupPrecOfScreen;
  var groupsToRender = [activeGroup];
  for (
    var index = 1;
    accoumilatedRightMargin < rightRenderBuffer ||
    accoumilatedLeftMargin < leftRenderBuffer;
    index++
  ) {
    var groupToRight = groups[activeGroupIndex + index];
    var groupToLeft = groups[activeGroupIndex - index];
    if (groupToRight && accoumilatedRightMargin < rightRenderBuffer) {
      var groupPrecOfScreen = groupToRight[unit] / size;
      accoumilatedRightMargin += groupPrecOfScreen;
      groupsToRender.push(groupToRight);
    }
    if (groupToLeft && accoumilatedLeftMargin < leftRenderBuffer) {
      var groupPrecOfScreen = groupToLeft[unit] / size;
      accoumilatedLeftMargin += groupPrecOfScreen;
      groupsToRender.push(groupToLeft);
    }
    if (!groupToLeft && !groupToRight) {
      break;
    }
  }
  return groups.map(function (group) {
    return { group: group, shouldRender: groupsToRender.includes(group) };
  });
}
export function getItemsInViewportOrMarginByScrollLocation(_a) {
  var items = _a.items,
    options = _a.options,
    virtualizationSettings = _a.virtualizationSettings,
    galleryWidth = _a.galleryWidth,
    galleryHeight = _a.galleryHeight,
    scrollPosition = _a.scrollPosition;
  var _b = virtualizationSettings || {},
    _c = _b.enabled,
    enabled = _c === void 0 ? false : _c,
    _d = _b.forwardItemScrollMargin,
    forwardItemScrollMargin = _d === void 0 ? 10 : _d,
    _e = _b.backwardItemScrollMargin,
    backwardItemScrollMargin = _e === void 0 ? 10 : _e;
  if (!enabled) {
    return items.map(function (item) {
      return {
        item: item,
        shouldRender: true,
      };
    });
  }
  var isHorizontal =
    options.scrollDirection === GALLERY_CONSTS.scrollDirection.HORIZONTAL;
  var size = isHorizontal ? galleryWidth : galleryHeight;
  var unit = isHorizontal ? "width" : "height";
  function shouldRenderItem(item) {
    var group = item.group;
    var locationUnit = unit === "height" ? "top" : "left";
    var location = group[locationUnit];
    var locationEnd = location + group[unit];
    var viewportStart = scrollPosition - size * backwardItemScrollMargin;
    var viewportEnd = scrollPosition + size * forwardItemScrollMargin;
    return location > viewportStart && locationEnd < viewportEnd;
  }
  return items.map(function (item) {
    return {
      item: item,
      shouldRender: shouldRenderItem(item),
    };
  });
}
//# sourceMappingURL=virtualization.js.map

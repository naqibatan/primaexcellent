import { __assign } from "tslib";
import React, { useRef, useEffect } from "react";
// import tryLineHeightFixer from './tryLineHeightFixer'
import fixSingleSection from "../texts/NewLHF";
function fix(textsContainer) {
  if (!textsContainer) {
    console.log("LHF RETURN !textsContainer");
    return;
  }
  try {
    // hideEmptySections(textsContainer)
    fixSections(textsContainer);
  } catch (err) {
    console.log("LHF ERROR fixSections");
    console.error(err);
  }
  console.log("LHF FIX END");
}
function fixSections(textsContainer) {
  var sections = getSections(textsContainer);
  sections.forEach(fixSingleSection);
}
function getSections(textsContainer) {
  var x = textsContainer.querySelectorAll(".section");
  return Array.from(x);
}
var runLineHeightFixer = function (currentContainer) {
  return fix(currentContainer.current);
};
var MasterInfoElement = function (props) {
  var masterInfoConfig = props.masterInfoConfig,
    CompsMap = props.CompsMap,
    shouldControlHorizontalAlignment = props.shouldControlHorizontalAlignment;
  var container = useRef(null);
  useEffect(
    function () {
      runLineHeightFixer(container); // waiting for wix inline styles to take affect
    },
    [masterInfoConfig]
  );
  var master = createMasterInfo(
    masterInfoConfig,
    CompsMap,
    shouldControlHorizontalAlignment
  );
  var style = {
    paddingLeft: masterInfoConfig.paddingLeft,
    paddingRight: masterInfoConfig.paddingRight,
    paddingTop: masterInfoConfig.paddingTop,
    paddingBottom: masterInfoConfig.paddingBottom,
    boxSizing: "border-box",
    height: "100%",
  };
  return React.createElement("div", { ref: container, style: style }, master);
};
var Section = function (props) {
  var justifyContent = {
    top: "flex-start",
    middle: "center",
    bottom: "flex-end",
  }[props.position];
  var innerStyle = {
    display: "flex",
    overflow: "hidden",
    flexDirection: "column",
    /* border: 'solid blue 3px', */
    justifyContent: justifyContent,
  };
  return React.createElement(
    "div",
    { className: "section ".concat(props.position), style: innerStyle },
    React.createElement("div", null, props.children)
  );
};
var Aligner = function (props) {
  var horizontalAlignmentClass = props.horizontalAlignment.toLowerCase();
  var style = {
    display: "flex",
    // textAlign: props.horizontalAlignment as 'left' | 'right' | 'center',
    // justifyContent: horizontalAlignmentClass,
    paddingBottom: "".concat(props.paddingBottom, "px"),
  };
  return React.createElement(
    "div",
    { className: horizontalAlignmentClass, style: style },
    props.children
  );
};
function SingleInfo(props) {
  var InfoClass = props.InfoClass,
    infoParams = props.infoParams;
  return React.createElement(
    Aligner,
    { horizontalAlignment: infoParams.horizontalAlignment },
    React.createElement(
      InfoClass,
      __assign({}, infoParams, {
        isNewInfoElements: true,
        shouldControlHorizontalAlignment:
          props.shouldControlHorizontalAlignment,
        horizontalAlignment: infoParams.horizontalAlignment,
        internalOrExternal: props.internalOrExternal,
        paddingBottom: infoParams.paddingBottom,
        paddingTop: infoParams.paddingTop,
        paddingLeft: infoParams.paddingLeft,
        paddingRight: infoParams.paddingRight,
      })
    )
  );
}
/* Icons: {CompClass: InfoIcons, pathForData: 'iconsParams'}, */
function createSection(
  orderList,
  masterInfoConfig,
  CompsMap,
  shouldControlHorizontalAlignment
) {
  var handlerRender = function (x) {
    var infoParams = masterInfoConfig[x.pathInData];
    return React.createElement(SingleInfo, {
      InfoClass: x.comp,
      key: x.pathInData,
      infoParams: infoParams,
      internalOrExternal: masterInfoConfig.masterType,
      shouldControlHorizontalAlignment: shouldControlHorizontalAlignment,
    });
  };
  return orderList
    .filter(function (x) {
      return masterInfoConfig.enabled[x];
    })
    .map(function (x) {
      return CompsMap[x];
    })
    .map(handlerRender);
}
function createRealSection(
  sName,
  masterInfoConfig,
  CompsMap,
  shouldControlHorizontalAlignment
) {
  var orderList = masterInfoConfig.order[sName];
  var rendererComps = createSection(
    orderList,
    masterInfoConfig,
    CompsMap,
    shouldControlHorizontalAlignment
  );
  var style = {};
  if (rendererComps.length === 0) {
    style.display = "none";
  }
  return (
    // @ts-ignore
    React.createElement(
      Section,
      { key: sName, position: sName, style: style },
      rendererComps
    )
  );
}
function createMasterInfo(
  masterInfoConfig,
  CompsMap,
  shouldControlHorizontalAlignment
) {
  /* const masterInfoConfig = config[masterInfoName] */
  var top = "top";
  var middle = "middle";
  var bottom = "bottom";
  var sections = [top, middle, bottom].map(function (x) {
    return createRealSection(
      x,
      masterInfoConfig,
      CompsMap,
      shouldControlHorizontalAlignment
    );
  });
  var gridStyle = {
    display: "grid",
    height: "100%",
    /* gridAutoRows: '1fr', */
  };
  var classes = ["parent"];
  if (masterInfoConfig.masterType === "internal") {
    classes.push("hover-info-element");
  }
  return React.createElement(
    "div",
    {
      key: masterInfoConfig.masterType,
      className: classes.join(" "),
      style: gridStyle,
    },
    sections
  );
}
export { MasterInfoElement };
//# sourceMappingURL=MasterInfoElement.js.map

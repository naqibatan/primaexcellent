import { GALLERY_v4_CONSTS } from "@wix/photography-client-lib";
import { window, experiments, designConsts } from "@wix/photography-client-lib";
function getVerticalMarginsAndPaddings3(infoToClamp) {
  var singleInfoStyle = getComputedStyle(infoToClamp);
  var result = 0;
  result += getNumberFromPx(singleInfoStyle.paddingBottom);
  result += getNumberFromPx(singleInfoStyle.paddingTop);
  result += getNumberFromPx(singleInfoStyle.borderTop);
  result += getNumberFromPx(singleInfoStyle.borderBottom);
  result += getNumberFromPx(singleInfoStyle.marginBottom);
  result += getNumberFromPx(singleInfoStyle.marginTop);
  return result;
}
function clampInfo(_a) {
  var infoToClamp = _a.infoToClamp,
    availableHeight = _a.availableHeight;
  log(infoToClamp, "CLAMP START availableHeight " + availableHeight);
  var availableHeightWithoutPaddingBottomAndMarginBottom = availableHeight;
  var verticalPaddingsAndMargins = getVerticalMarginsAndPaddings3(infoToClamp);
  availableHeightWithoutPaddingBottomAndMarginBottom -=
    verticalPaddingsAndMargins;
  log(
    infoToClamp,
    "availableHeightWithoutPaddingBottomAndMarginBottom ".concat(
      availableHeightWithoutPaddingBottomAndMarginBottom
    )
  );
  if (availableHeightWithoutPaddingBottomAndMarginBottom < 0) {
    availableHeightWithoutPaddingBottomAndMarginBottom = 0;
  }
  var fontSize = parseInt(getCss(infoToClamp, "font-size", 16));
  var lineHeight = getLineHeightInPixels(
    getCss(infoToClamp, "line-height", "normal"),
    fontSize
  );
  log(infoToClamp, "clamp lineHeight: ".concat(lineHeight));
  var numOfLines = Math.floor(
    availableHeightWithoutPaddingBottomAndMarginBottom / lineHeight
  );
  log(infoToClamp, "LHF clamp numOfLines: ".concat(numOfLines));
  clampLinesOrHideIfNoSpace(infoToClamp, numOfLines);
  log(infoToClamp, "CLAMP END");
}
function clampLinesOrHideIfNoSpace(infoToClamp, numOfLines) {
  var span = infoToClamp.querySelector("span");
  if (numOfLines === 0) {
    setCss(infoToClamp, {
      display: "none",
    });
    return;
  }
  setCss(span, {
    "-webkit-box-orient": "vertical",
    display: "-webkit-box",
    overflow: "hidden",
    "-webkit-line-clamp": numOfLines + "",
  });
}
function setCss(element, styles) {
  try {
    Object.assign(element.style, styles);
  } catch (e) {
    console.log("LHF set css error");
    //
  }
}
function getCss(element, rule, _default) {
  return window.getComputedStyle(element)[rule] || _default;
}
function getNumberFromPx(lineHeightValue) {
  return lineHeightValue && lineHeightValue.includes("px")
    ? parseInt(lineHeightValue)
    : 0;
}
function getVerticalMarginsAndPaddings2(singleInfo) {
  var singleInfoStyle = getComputedStyle(singleInfo);
  if (!singleInfoStyle) {
    console.log("LHF no singleInfoStyle");
    return 0;
  }
  return ["marginTop", "marginBottom", "paddingTop", "paddingBottom"]
    .map(function (x) {
      return getNumberFromPx(singleInfoStyle.x);
    })
    .reduce(function (prev, current) {
      return prev + current;
    }, 0);
}
function getVerticalPaddings(singleInfo) {
  var singleInfoStyle = getComputedStyle(singleInfo);
  if (!singleInfoStyle) return 0;
  return (
    getNumberFromPx(singleInfoStyle.paddingTop) +
    getNumberFromPx(singleInfoStyle.paddingBottom)
  );
}
function getVerticalMargins(singleInfo) {
  var singleInfoStyle = getComputedStyle(singleInfo);
  if (!singleInfoStyle) return 0;
  return (
    getNumberFromPx(singleInfoStyle.marginTop) +
    getNumberFromPx(singleInfoStyle.marginBottom)
  );
}
function getLineHeightInPixels(lineHeightValue, fontSize) {
  fontSize = parseInt(fontSize);
  if (lineHeightValue.includes("px")) {
    return parseInt(lineHeightValue);
  } else {
    return fontSize * 1.2; // is case we get 'normal' multiply by 1.2
  }
}
function getSavedDisplay(element) {
  return (element && element.getAttribute("data-display")) || "-webkit-box";
}
function getPaddingsAndBorder(element) {
  var cs = window.getComputedStyle(element);
  if (cs == null) {
    console.log(
      "LHF warning: getComputedStyle is null, return 0 paddings and borders"
    );
    return { paddingX: 0, paddingY: 0, borderX: 0, borderY: 0 };
  }
  var paddingY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
  var paddingX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
  var borderX =
    parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth);
  var borderY =
    parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth);
  return {
    paddingX: paddingX,
    paddingY: paddingY,
    borderX: borderX,
    borderY: borderY,
  };
}
function getDimensions(element) {
  var _a = getPaddingsAndBorder(element),
    paddingX = _a.paddingX,
    paddingY = _a.paddingY,
    borderX = _a.borderX,
    borderY = _a.borderY;
  return {
    width: element.clientWidth - paddingX - borderX,
    height: element.offsetHeight,
  };
}
function getSections(textsContainer) {
  var x = textsContainer.querySelectorAll(".section");
  return Array.from(x);
}
function getInfosInsideSection(section) {
  return Array.from(section.querySelectorAll(".info-member"));
}
function hideEmptySections(textsContainer) {
  var sections = getSections(textsContainer);
  sections.forEach(function (section) {
    var infosInsideSection = getInfosInsideSection(section);
    if (infosInsideSection.length === 0) {
      setCss(section, { display: "none" });
    }
  });
}
function log(el, message) {
  console.log("LHF  ".concat(el.classList.value, ": ").concat(message));
}
function fixSingleSection(section) {
  var sectionRemainingHeight = section.offsetHeight;
  log(section, "sectionRemainingHeight start " + sectionRemainingHeight);
  getInfosInsideSection(section).forEach(function (info) {
    sectionRemainingHeight = clampInfoIfNeeded(info, sectionRemainingHeight);
  });
}
function clampInfoIfNeeded(info, sectionRemainingHeight) {
  var infoHeightIncludingBordersAndPaddings = info.offsetHeight;
  var infoVerticalMargins = getVerticalMargins(info);
  var infoFullHeight =
    infoHeightIncludingBordersAndPaddings + infoVerticalMargins;
  log(
    info,
    "infoHeightIncludingBordersAndPaddings: "
      .concat(infoHeightIncludingBordersAndPaddings, ", infoVerticalMargins: ")
      .concat(infoVerticalMargins, ". infoFullHeight: ")
      .concat(infoFullHeight)
  );
  if (infoFullHeight > sectionRemainingHeight) {
    // not enough room for current info
    clampInfo({
      infoToClamp: info,
      availableHeight: sectionRemainingHeight,
    });
    return 0;
  } else {
    return sectionRemainingHeight - infoFullHeight;
  }
}
export default fixSingleSection;
//# sourceMappingURL=NewLHF.js.map

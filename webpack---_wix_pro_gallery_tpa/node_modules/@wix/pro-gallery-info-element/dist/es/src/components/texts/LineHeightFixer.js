import { GALLERY_v4_CONSTS } from "@wix/photography-client-lib";
import { window, experiments, designConsts } from "@wix/photography-client-lib";
var minWidthToShowContent = 135;
var minWithForNormalSizedItem = 190;
function sizeOf(elementComputedStyle, cssProperty) {
  return parseInt(elementComputedStyle[cssProperty], 10);
}
var LineHeightFixer = /** @class */ (function () {
  function LineHeightFixer() {}
  LineHeightFixer.prototype.isSlideshow = function (options) {
    return GALLERY_v4_CONSTS.isLayout("SLIDESHOW")(options);
  };
  LineHeightFixer.prototype.getDimensions = function (element) {
    var cs = window.getComputedStyle(element);
    var paddingY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
    var paddingX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
    var borderX =
      parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth);
    var borderY =
      parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth);
    return {
      width: element.clientWidth - paddingX - borderX,
      height: element.clientHeight - paddingY - borderY,
    };
  };
  LineHeightFixer.prototype.saveCurrentDisplay = function (element) {
    if (!element) return;
    var curDisplay = this.getCss(element, "display");
    if (curDisplay !== "none") {
      element.setAttribute("data-display", this.getCss(element, "display"));
    }
  };
  LineHeightFixer.prototype.removeElement = function (element) {
    this.saveCurrentDisplay(element);
    element.classList.add("hide");
  };
  LineHeightFixer.prototype.hideElement = function (element) {
    if (element) {
      this.setCss(element, { visibility: "hidden" });
    }
  };
  LineHeightFixer.prototype.showElement = function (element) {
    this.setCss(element, { visibility: "inherit" });
  };
  LineHeightFixer.prototype.getCss = function (element, rule, _default) {
    return window.getComputedStyle(element)[rule] || _default;
  };
  LineHeightFixer.prototype.setCss = function (element, styles) {
    try {
      Object.assign(element.style, styles);
    } catch (e) {
      //
    }
  };
  LineHeightFixer.prototype.shouldFix = function (oldProps, newProps) {
    var options = oldProps.options,
      title = oldProps.title,
      description = oldProps.description,
      style = oldProps.style,
      externalTotalInfoHeight = oldProps.externalTotalInfoHeight;
    var newOptions = newProps.options;
    var newTitle = newProps.title;
    var newDescription = newProps.description;
    var newStyle = newProps.style;
    var newExternalTotalInfoHeight = newProps.externalTotalInfoHeight;
    var newIsSocialPopulated =
      newOptions.allowSocial ||
      newOptions.loveButton ||
      newOptions.allowDownload;
    var oldIsSocialPopulated =
      options.allowSocial || options.loveButton || options.allowDownload;
    return (
      style.height !== newStyle.height ||
      externalTotalInfoHeight !== newExternalTotalInfoHeight ||
      style.width !== newStyle.width ||
      this.isSlideshow(options) !== this.isSlideshow(newOptions) ||
      options.allowTitle !== newOptions.allowTitle ||
      options.allowDescription !== newOptions.allowDescription ||
      options.slideshowInfoSize !== newOptions.slideshowInfoSize ||
      options.textImageSpace !== newOptions.textImageSpace ||
      options.textsVerticalPadding !== newOptions.textsVerticalPadding ||
      options.textsHorizontalPadding !== newOptions.textsHorizontalPadding ||
      options.titleDescriptionSpace !== newOptions.titleDescriptionSpace ||
      options.imageInfoType !== newOptions.imageInfoType ||
      options.itemDescriptionFont !== newOptions.itemDescriptionFont ||
      options.calculateTextBoxHeightMode !==
        newOptions.calculateTextBoxHeightMode ||
      options.itemFont !== newOptions.itemFont ||
      oldIsSocialPopulated !== newIsSocialPopulated ||
      title !== newTitle ||
      description !== newDescription
    );
  };
  LineHeightFixer.prototype.calcAvailableHeight = function (
    props,
    textsContainerAvailableHeight
  ) {
    var options = props.options,
      infoContainer = props.infoContainer;
    var availableHeight;
    if (this.isSlideshow(options)) {
      var socialElements = infoContainer.getElementsByClassName(
        "info-element-social"
      );
      var socialElement = socialElements.length > 0 && socialElements[0];
      var socialHeight = 0;
      var socialMarginBottom = 0;
      if (socialElement) {
        socialHeight = socialElement.clientHeight;
        socialMarginBottom = parseInt(
          this.getCss(socialElement, "margin-bottom", 0)
        );
      } else {
        var socialIsPopulated =
          options.allowSocial || options.loveButton || options.allowDownload;
        if (socialIsPopulated) {
          // no socialElement at the moment (in SSR we render only TextInfoElement), but should be (will be in CSR, when we will render InfoElement)
          socialHeight = 24; // height of info-element-social
          socialMarginBottom = 24; // margin-bottom of info-element-social populated-item
        }
      }
      var itemInfoChildDivPaddingTop = 24; // padding-top of slideshow-info-element-inner
      availableHeight =
        options.slideshowInfoSize -
        itemInfoChildDivPaddingTop -
        socialHeight -
        socialMarginBottom;
    } else {
      availableHeight = textsContainerAvailableHeight;
    }
    return availableHeight;
  };
  LineHeightFixer.prototype.fix = function (props, textsContainer) {
    var options = props.options,
      title = props.title,
      description = props.description;
    if (
      !textsContainer ||
      (this.isSlideshow(options) && !props.infoContainer) // calcAvailableHeight when slideshow is using infoContainer
    ) {
      return;
    }
    for (
      var _i = 0, _a = options.titlePlacement.split(",");
      _i < _a.length;
      _i++
    ) {
      var placement = _a[_i];
      var textPlacementRightOrLeft =
        GALLERY_v4_CONSTS.hasExternalHorizontalPlacement(placement);
      var textPlacementAboveOrBelow =
        GALLERY_v4_CONSTS.hasExternalVerticalPlacement(placement);
      var availableDimensions = this.getDimensions(textsContainer);
      if (props.isNewInfoElements) {
        console.log("newInfo - decrease social size   ");
        var social = textsContainer.querySelector(".info-element-social");
        if (social) {
          var socialStyle = window.getComputedStyle(social);
          var socialHeight =
            sizeOf(socialStyle, "height") +
            sizeOf(socialStyle, "paddingTop") +
            sizeOf(socialStyle, "paddingBottom");
          console.log("socialHeight", socialHeight);
          availableDimensions.height -= socialHeight;
        }
      }
      if (
        Object.values(availableDimensions).some(function (val) {
          return val <= 0;
        })
      ) {
        return false; // dimensions are not available to create a fix
      }
      var availableHeight = this.calcAvailableHeight(
        props,
        availableDimensions.height
      );
      var customButtonElements = textsContainer.getElementsByClassName(
        "info-element-custom-button-wrapper"
      );
      var titleElements =
        textsContainer.getElementsByClassName("info-element-title");
      var descriptionElements = textsContainer.getElementsByClassName(
        "info-element-description"
      );
      var customButtonExists = customButtonElements.length > 0;
      var customButtonElement = customButtonExists && customButtonElements[0];
      var titleElement = titleElements.length > 0 && titleElements[0];
      var descriptionElement =
        descriptionElements.length > 0 && descriptionElements[0];
      var isItemWidthToSmall =
        availableDimensions.width < minWidthToShowContent;
      this.hideElement(titleElement);
      this.setCss(titleElement, { overflow: "hidden" });
      this.hideElement(descriptionElement); // if textPlacementAboveOrBelow or textPlacementRightOrLeft, descriptionElement should not get 'display: -webkit-box'
      this.setCss(descriptionElement, { overflow: "hidden" });
      this.hideElement(customButtonElement);
      if (customButtonExists) {
        var buttonHeight = this.getDimensions(customButtonElement).height;
        if (Number.isNaN(buttonHeight) || availableHeight + 30 < buttonHeight) {
          this.removeElement(customButtonElement);
          customButtonExists = false;
        } else if (isItemWidthToSmall) {
          this.setCss(customButtonElement.querySelector("button"), {
            "min-width": 0 + "px",
            "max-width": minWidthToShowContent + "px",
          });
          this.showElement(customButtonElement);
        } else if (availableDimensions.width < minWithForNormalSizedItem) {
          this.setCss(customButtonElement.querySelector("button"), {
            "min-width": minWidthToShowContent + "px",
            "max-width": availableDimensions.width + "px",
          });
          this.showElement(customButtonElement);
        } else {
          // show the button without any additional changes
          this.showElement(customButtonElement);
        }
        if (customButtonExists) {
          availableHeight -= buttonHeight;
          availableHeight -= designConsts.spaceBetweenElements;
          if (availableHeight < 0) {
            availableHeight = 0;
          }
        }
      }
      var titleNumOfAvailableLines = 0;
      var shouldDisplayTitle = titleElement && title && options.allowTitle;
      if (shouldDisplayTitle) {
        this.setCss(titleElement, { overflow: "visible" });
        if (titleElements.length === 1) {
          var titleHeight = // when padding is large and the we decrease padding the clientHeight stay small
            parseInt(titleElement.children[0].offsetHeight) >
            parseInt(titleElement.clientHeight)
              ? parseInt(titleElement.children[0].offsetHeight)
              : parseInt(titleElement.clientHeight);
          var titleFontSize = parseInt(
            this.getCss(titleElement, "font-size", 16)
          );
          var titleLineHeight = this.getLineHeightInPixels(
            this.getCss(titleElement, "line-height", "normal"),
            titleFontSize
          );
          var numOfTitleLines = 1;
          if (titleHeight >= titleLineHeight) {
            numOfTitleLines = Math.floor(titleHeight / titleLineHeight);
          }
          titleNumOfAvailableLines = Math.floor(
            availableHeight / titleLineHeight
          );
          if (titleNumOfAvailableLines === 0) {
            this.removeElement(titleElement);
          } else {
            this.setCss(titleElement, { overflow: "hidden" });
            this.showElement(titleElement);
            var isTitleFitInAvailableHeight =
              titleNumOfAvailableLines >= numOfTitleLines;
            if (isTitleFitInAvailableHeight) {
              this.setCss(titleElement, { "-webkit-line-clamp": "none" });
              titleHeight = titleLineHeight * numOfTitleLines;
            } else {
              this.setCss(titleElement, {
                "-webkit-line-clamp": titleNumOfAvailableLines + "",
              });
              titleHeight = titleLineHeight * titleNumOfAvailableLines;
            }
            var isThereAnyAvailableHeightLeft = availableHeight > titleHeight;
            if (isThereAnyAvailableHeightLeft) {
              availableHeight -= titleHeight;
            } else {
              availableHeight = 0;
            }
          }
        }
      }
      var shouldDisplayDescription =
        descriptionElement &&
        description &&
        options.allowDescription &&
        availableHeight > 0 &&
        ((shouldDisplayTitle && titleNumOfAvailableLines > 0) ||
          !shouldDisplayTitle); // when there s no place for title the description not suppose to be shown
      if (shouldDisplayDescription) {
        this.setCss(descriptionElement, { overflow: "visible" });
        if (shouldDisplayTitle) {
          availableHeight -= options.titleDescriptionSpace || 0;
        }
        if (availableHeight < 0) {
          availableHeight = 0;
        }
        var descriptionFontSize = parseInt(
          this.getCss(descriptionElement, "font-size", 16)
        );
        var lineHeight = this.getLineHeightInPixels(
          this.getCss(descriptionElement, "line-height", "normal"),
          descriptionFontSize
        );
        var numOfLines = Math.floor(availableHeight / lineHeight);
        if (numOfLines === 0) {
          this.removeElement(descriptionElement);
          this.setCss(titleElement, {
            marginBottom: designConsts.spaceBetweenElements + "px",
          });
        } else {
          this.setCss(descriptionElement, {
            overflow: "hidden",
            "-webkit-line-clamp": numOfLines + "",
          });
          this.showElement(descriptionElement); // if textPlacementAboveOrBelow or textPlacementRightOrLeft, descriptionElement should not get 'display: -webkit-box'
        }
      }
    }
    return true;
  };
  LineHeightFixer.prototype.getLineHeightInPixels = function (
    lineHeightValue,
    fontSize
  ) {
    fontSize = parseInt(fontSize);
    if (lineHeightValue.includes("px")) {
      return parseInt(lineHeightValue);
    } else {
      return fontSize * 1.2; // is case we get 'normal' multiply by 1.2
    }
  };
  return LineHeightFixer;
})();
export default new LineHeightFixer();
//# sourceMappingURL=LineHeightFixer.js.map

import { __assign } from "tslib";
import * as React from "react";
// For editor-flow projects, this package is being replaced with private @tpa-style-webpack-plugin.
import {
  getProcessedCss,
  getStaticCss,
} from "tpa-style-webpack-plugin/runtime";
import {
  getSiteCssVariables,
  getComponentCssVariables,
} from "@wix/tpa-style-webpack-plugin/css-vars";
import * as utils from "../../constants/constants";
export var withStyles = function (Component, options) {
  var cssFiles = [].concat(options.cssPath || []);
  var rtlCssFiles = [].concat(options.rtlCssPath || []);
  var ltrCssFiles = [].concat(options.ltrCssPath || []);
  var shouldUseFiles = rtlCssFiles.length;
  var WithStyles = function (props) {
    var isMobile = props.isMobile,
      isRTL = props.isRTL,
      isEditorX = props.isEditorX;
    var host = props.host,
      prefixStaticCss = props.prefixStaticCss,
      cssBaseUrl = props.cssBaseUrl;
    var cssFilesToLoad = React.useMemo(
      function () {
        return cssFiles.concat(isRTL ? rtlCssFiles : ltrCssFiles);
      },
      [isRTL]
    );
    var _a = React.useState(function () {
        var state = 0;
        if (!utils.canUseDom()) {
          return state;
        }
        for (
          var _i = 0, _a = Array.from(document.styleSheets);
          _i < _a.length;
          _i++
        ) {
          var styleSheet = _a[_i];
          if (typeof styleSheet.href === "string") {
            var filePath = styleSheet.href.replace(cssBaseUrl || "", "");
            if (cssFilesToLoad.includes(filePath)) {
              state++;
            }
          }
        }
        return state;
      }),
      loaded = _a[0],
      setLoaded = _a[1];
    var style =
      props.style || (host === null || host === void 0 ? void 0 : host.style);
    var styleId =
      (host === null || host === void 0 ? void 0 : host.id) || props.id;
    var prefixSelector = styleId ? ".".concat(styleId) : "";
    var preloaded = React.useMemo(function () {
      if (utils.canUseDom()) {
        var links = document.querySelectorAll(
          "".concat(prefixSelector, " link")
        );
        return links.length;
      }
      return cssFilesToLoad.length;
    }, []);
    var css = React.useMemo(
      function () {
        return getProcessedCss(
          style,
          {
            prefixSelector: prefixSelector,
            isRTL: !!isRTL,
            isMobile: !!isMobile,
            isEditorX: !!isEditorX,
            strictMode: !!options.strictMode,
            dimensions: host && host.dimensions,
          },
          options.defaults
        );
      },
      [
        JSON.stringify(style),
        JSON.stringify(
          host === null || host === void 0 ? void 0 : host.dimensions
        ),
        isRTL,
        isMobile,
        isEditorX,
        prefixSelector,
      ]
    );
    var cssVars = React.useMemo(
      function () {
        var siteCssVars = getSiteCssVariables(
          style.siteColors,
          style.siteTextPresets
        );
        var widgetCssVars = getComponentCssVariables(
          style,
          {},
          {},
          {
            prefixSelector: prefixSelector,
            isRTL: !!isRTL,
            isMobile: !!isMobile,
            isEditorX: !!isEditorX,
            strictMode: !!options.strictMode,
            dimensions: host && host.dimensions,
          },
          options.defaults,
          options.customCssVars
        );
        return ""
          .concat(prefixSelector, " {\n            ")
          .concat(siteCssVars.stylesheet, "\n            ")
          .concat(widgetCssVars.stylesheet, "\n        }");
      },
      [
        JSON.stringify(style),
        JSON.stringify(
          host === null || host === void 0 ? void 0 : host.dimensions
        ),
        isRTL,
        isMobile,
        isEditorX,
        prefixSelector,
      ]
    );
    var staticCss = React.useMemo(
      function () {
        return getStaticCss(
          prefixStaticCss && prefixSelector
            ? { prefixSelector: prefixSelector }
            : undefined
        );
      },
      [prefixSelector, prefixStaticCss]
    );
    var isReady = loaded + preloaded >= cssFilesToLoad.length;
    return React.createElement(
      "div",
      { className: styleId },
      cssBaseUrl && shouldUseFiles
        ? cssFilesToLoad.map(function (fileName) {
            return React.createElement("link", {
              href: "".concat(cssBaseUrl).concat(fileName),
              rel: "stylesheet",
              type: "text/css",
              key: fileName,
              onLoad: handleLinkLoad,
            });
          })
        : null,
      cssVars &&
        React.createElement("style", {
          dangerouslySetInnerHTML: { __html: cssVars },
        }),
      staticCss &&
        !shouldUseFiles &&
        React.createElement("style", {
          dangerouslySetInnerHTML: { __html: staticCss },
        }),
      React.createElement("style", {
        dangerouslySetInnerHTML: { __html: css },
      }),
      shouldUseFiles && isReady
        ? React.createElement(Component, __assign({}, props))
        : null,
      !shouldUseFiles && React.createElement(Component, __assign({}, props))
    );
    function handleLinkLoad() {
      setLoaded(function (count) {
        return count + 1;
      });
    }
  };
  WithStyles.displayName = "WithStyles";
  WithStyles.tokenForCiPoliceRule = "a221ab11-8d7e-4f36-bf44-fd8f380d96ee";
  return WithStyles;
};
//# sourceMappingURL=withStyles.js.map

import {
  getManifestName,
  withProdNamespace,
} from "@wix/editor-elements-conventions";
import { createResourceLoader } from "./loaders/createResourceLoader";
import { createManifestAPI } from "./manifest/createManifestAPI";
import {
  createLazyComponentLoaders,
  createEagerComponentLoaders,
  getComponentAssets,
} from "./loaders/createComponentLoaders";
import {
  loadExternalRegistry,
  EXTERNAL_REGISTRY_OVERRIDE_NAMESPACE,
} from "./loaders/loadExternalRegistry";
import { validateLibraryURL } from "./toolbox/validateLibraryURL";
import { flat } from "./utils";
import { createEsmResourceLoader } from "./loaders/createEsmResourceLoader";
import SentryReporter from "./sentry";
export function withDefaultOptions(options) {
  return {
    dev: false,
    useScriptsInsteadOfEval: false,
    usePartialManifests: false,
    useExperimentalEval: false,
    useLazyLoadersInit: false,
    useEsmLoader: false,
    ...options,
  };
}
export const isLibraryTopology = (library) => {
  return library.hasOwnProperty("namespace") && library.hasOwnProperty("url");
};
export async function loadContext({
  host,
  libraries,
  resourceLoader,
  options,
}) {
  const urls = [];
  const manifests = [];
  libraries.forEach((library, index) => {
    if (isLibraryTopology(library)) {
      const manifestName = getManifestName({
        namespace: library.namespace,
        host,
        isDev: false,
      });
      const url = `${library.url}/${manifestName}`;
      urls.push({ url, order: index });
    } else {
      manifests.push({
        manifest: createManifestAPI(library),
        order: index,
      });
    }
  });
  const loadManifests = () => {
    return Promise.all(
      urls.map(async ({ url, order }) => {
        const manifest = await resourceLoader.fetchLibraryManifest({
          url,
        });
        return {
          order,
          manifest: createManifestAPI(manifest),
        };
      })
    );
  };
  if (!options.usePartialManifests) {
    manifests.push(...(await loadManifests()));
  }
  return {
    manifests,
    urls: urls.map(({ url }) => url),
    loadManifests: options.usePartialManifests ? loadManifests : null,
  };
}
function splitLibraries(libraries) {
  return libraries.reduce(
    (acc, lib) => {
      if (
        isLibraryTopology(lib) &&
        lib.namespace === EXTERNAL_REGISTRY_OVERRIDE_NAMESPACE
      ) {
        acc.registryOverrideLibrary = lib;
      } else {
        acc.libraries.push(lib);
      }
      return acc;
    },
    {
      libraries: [],
      registryOverrideLibrary: null,
    }
  );
}
function filterUntrustedURLs(libraries) {
  return libraries.filter((library) => {
    if (isLibraryTopology(library)) {
      return validateLibraryURL(library.url);
    } else {
      return validateLibraryURL(library.baseURL);
    }
  });
}
export function createRegistry({ host }) {
  return async ({ getSentryClient, ...params }) => {
    let sentryReporter;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const captureException = (exception, hint) => {
      try {
        sentryReporter =
          sentryReporter ?? new SentryReporter(host, getSentryClient);
        return sentryReporter.captureException(exception, hint);
      } catch (error) {
        console.log("Failed to initialize sentry with error:", error);
      }
      return;
    };
    const options = withDefaultOptions(params.options || {});
    const resourceLoaderFactory = options.useEsmLoader
      ? createEsmResourceLoader
      : createResourceLoader;
    const resourceLoader = resourceLoaderFactory({
      options,
      fetcher: params.fetcher,
      globals: params.globals,
    });
    const { libraries, registryOverrideLibrary } = splitLibraries(
      filterUntrustedURLs(params.libraries)
    );
    if (registryOverrideLibrary) {
      const registry = await loadExternalRegistry({
        resourceLoader,
        host,
        url: registryOverrideLibrary.url,
      });
      return registry({ ...params, libraries });
    }
    const context = await loadContext({
      host,
      libraries,
      resourceLoader,
      options,
    });
    let loaders = {};
    const librariesComponents = {};
    async function createComponentLoaders(manifests) {
      const tasks = manifests.map(async ({ order, manifest }) => {
        const loadBundle = resourceLoader.createBundleLoader({
          environment: manifest.getEnvironment(),
        });
        // without *.local
        const namespace = withProdNamespace(manifest.getNamespace());
        const mode =
          (params.modes && params.modes[namespace]) || params.mode || "lazy";
        librariesComponents[order] =
          mode === "lazy"
            ? await createLazyComponentLoaders({
                manifest,
                loadBundle,
              })
            : await createEagerComponentLoaders({
                manifest,
                loadBundle,
              });
      });
      await Promise.all(tasks);
      loaders = {};
      Object.keys(librariesComponents)
        .map((v) => parseInt(v, 10))
        .sort()
        .forEach((index) => {
          Object.assign(loaders, librariesComponents[index]);
        });
    }
    if (!options.useLazyLoadersInit) {
      await createComponentLoaders(context.manifests);
    }
    const loadComponents = async (componentNames) => {
      const pending = componentNames.map(async (componentName) => {
        return {
          componentName,
          model: await loaders[componentName](),
        };
      });
      const models = await Promise.all(pending);
      return models.reduce((acc, { model, componentName }) => {
        acc[componentName] = model;
        return acc;
      }, {});
    };
    let isContextFulfilled = false;
    let areComponentsLoadersCreated = !options.useLazyLoadersInit;
    const pendingPromises = {};
    return {
      getComponentsLoaders() {
        return loaders;
      },
      getManifestURLs() {
        return [...context.urls];
      },
      getHostBundleAssets() {
        return flat(
          context.manifests.map(({ manifest }) => {
            const model = manifest.getHostBundleModel();
            return getComponentAssets({ resource: model });
          })
        );
      },
      async loadComponents(componentNames) {
        return loadComponents(componentNames);
      },
      loadAllComponents() {
        const componentNames = Object.keys(loaders);
        return loadComponents(componentNames);
      },
      getLibrariesAssets() {
        return flat(
          context.manifests.map(({ manifest }) => manifest.getLibraryAssets())
        );
      },
      getRuntime() {
        const _libraries = [
          ...context.manifests.map(({ manifest }) => manifest.getManifest()),
        ];
        if (registryOverrideLibrary) {
          _libraries.push(registryOverrideLibrary);
        }
        return {
          libraries: _libraries,
        };
      },
      async ensureComponentLoadersAreCreated() {
        if (!areComponentsLoadersCreated) {
          if (!pendingPromises.componentsLoaders) {
            pendingPromises.componentsLoaders = createComponentLoaders(
              context.manifests
            );
          }
          await pendingPromises.componentsLoaders;
          areComponentsLoadersCreated = true;
          pendingPromises.componentsLoaders = null;
        }
      },
      async ensureManifestsAreLoaded() {
        if (!isContextFulfilled && context.loadManifests) {
          if (!pendingPromises.librariesManifests) {
            pendingPromises.librariesManifests = new Promise(
              async (resolve) => {
                const manifests = await context.loadManifests();
                await createComponentLoaders(manifests);
                resolve();
              }
            );
          }
          await pendingPromises.librariesManifests;
          isContextFulfilled = true;
          pendingPromises.librariesManifests = null;
        }
      },
    };
  };
}
//# sourceMappingURL=createRegistry.js.map

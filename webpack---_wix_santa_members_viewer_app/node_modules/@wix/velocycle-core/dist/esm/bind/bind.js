import { __spreadArrays } from "tslib";
import {
  getImperative,
  isEventHandler,
  isImperative,
  isRepeater,
  isNestedAttributes,
  isMultiStateBox,
  set,
  get,
} from "./helpers";
var observeRepeater = function (veloElement, getObservableParams, opts) {
  if (getObservableParams !== undefined) {
    var repeaterDisposers_1 = {};
    veloElement.onItemReady(
      opts.action(function ($item, itemData, index) {
        // for not all
        // item can return object with observable fields or just void
        var $bindItem = viewModelBindWrapper($item, opts);
        var itemCallResult = getObservableParams(itemData, $bindItem, index);
        if (itemCallResult) {
          var observeItem = viewModelBindAllWrapper($item, opts);
          var disposeItem = observeItem(itemCallResult);
          repeaterDisposers_1[itemData._id] = disposeItem;
        }
      })
    );
    veloElement.onItemRemoved(
      opts.action(function (itemData) {
        repeaterDisposers_1[itemData._id]();
      })
    );
  }
};
export var viewModelBindWrapper = function ($w, opts, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  return function (selector, attrSettings) {
    if (!attrSettings) {
      throw new Error("No selector found " + selector);
    }
    var veloElement =
      parentPath.length > 0 ? get($w(selector), parentPath) : $w(selector);
    var disposers = [];
    var isRepeaterType = isRepeater(attrSettings);
    if (isRepeaterType) {
      observeRepeater(veloElement, attrSettings.item, opts);
    }
    var isMultiStateBoxType = isMultiStateBox(attrSettings);
    if (isMultiStateBoxType && attrSettings.currentState) {
      var disposeChangeState = opts.reaction(
        attrSettings.currentState,
        function (data) {
          veloElement.changeState(data);
        },
        {
          fireImmediately: true,
        }
      );
      disposers.push(disposeChangeState);
    }
    var _loop_1 = function (attr, observableValue) {
      if (observableValue === undefined) {
        return "continue";
      }
      if (isRepeaterType && attr === "item") {
        return "continue";
      }
      if (isMultiStateBoxType && attr === "currentState") {
        return "continue";
      }
      if (isEventHandler(attr)) {
        // TODO: See if we detach it
        veloElement[attr](opts.action(observableValue));
        return "continue";
      }
      var currentPath = __spreadArrays(parentPath, [attr]);
      // Nested objects support
      if (isNestedAttributes(observableValue)) {
        var bindNestedField = viewModelBindWrapper($w, opts, currentPath);
        var disposeNestedField = bindNestedField(selector, observableValue);
        disposers.push(disposeNestedField);
        return "continue";
      }
      if (attr) {
        var disposeAttr = opts.reaction(
          observableValue,
          function (data) {
            if (isImperative(veloElement, attr)) {
              var imperativeKey = getImperative(attr)[data ? "on" : "off"];
              if (veloElement[imperativeKey]) {
                veloElement[imperativeKey]();
              } else if (process.env.NODE_ENV === "development") {
                console.warn(
                  "Can't convert declarative to imperative field \"" +
                    imperativeKey +
                    '" for ' +
                    selector +
                    " element"
                );
              }
            } else {
              set($w(selector), currentPath, data);
            }
          },
          {
            fireImmediately: true,
          }
        );
        disposers.push(disposeAttr);
      }
    };
    for (var _i = 0, _a = Object.entries(attrSettings); _i < _a.length; _i++) {
      var _b = _a[_i],
        attr = _b[0],
        observableValue = _b[1];
      _loop_1(attr, observableValue);
    }
    return function () {
      return disposers.forEach(function (f) {
        return f();
      });
    };
  };
};
export var viewModelBindAllWrapper = function ($w, opts) {
  return function (params) {
    var viewModelBind = viewModelBindWrapper($w, opts);
    var allDisposers = [];
    for (var _i = 0, _a = Object.entries(params); _i < _a.length; _i++) {
      var _b = _a[_i],
        selector = _b[0],
        attrSettings = _b[1];
      if (!attrSettings) {
        continue;
      }
      var disposeComponent = viewModelBind(selector, attrSettings);
      allDisposers.push(disposeComponent);
    }
    return function () {
      return allDisposers.forEach(function (f) {
        return f();
      });
    };
  };
};
//# sourceMappingURL=bind.js.map

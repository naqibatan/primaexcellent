/**
 * Round a number to the closest multiply of 'step'
 **/
export function round(step, num) {
  const mod = step ? num % step : 0;
  return mod > step / 2 ? num - mod + step : num - mod;
}

/**
 * Round with decimal precision, default round to integer
 */
export const roundPrecision = function (num, precision) {
  if (precision === void 0) {
    precision = 0;
  }
  return +num.toFixed(precision);
};

/**
 * Limit a number between 2 values, inclusive
 */
export function clamp(min, max, num) {
  return Math.min(max, Math.max(min, num));
}

/**
 *  Snap a number by distance to another number
 */
export function snap(to, dist, num) {
  return Math.abs(num - to) <= dist ? to : num;
}

/**
 * Snap a number by distance every multiple of another number
 */
export function snapEvery(to, dist, num) {
  const d1 = num % to;
  const d2 = to - d1;
  return d1 <= dist ? num - d1 : d2 <= dist ? num + d2 : num;
}

/**
 * Linear Interpulation
 * If t = 0 returns a, if t = 1 returns b, and transitions the value in-between
 */
export function lerp(a, b, t) {
  return a * (1 - t) + b * t;
}

/**
 * Map a value from one range 'a' to different range 'b'
 */
export function mapRange(a1, a2, b1, b2, num) {
  return ((num - a1) * (b2 - b1)) / (a2 - a1) + b1;
}

/**
 * Map a number from a range to a fraction between 0 and 1
 */
export function mapPercentage(start, end, num) {
  return mapRange(start, end, 0, 1, num);
}

/**
 * Get the distance between 2 points
 */
export function distance(_ref, _ref2) {
  let [x1, y1] = _ref;
  let [x2, y2] = _ref2;
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}
export function deg2rad(angleInDeg) {
  return (angleInDeg * Math.PI) / 180;
}
export function rad2deg(angleInRad) {
  return (angleInRad * 180) / Math.PI;
}
//# sourceMappingURL=math-and-numbers.js.map

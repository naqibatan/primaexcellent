/* eslint-disable no-new-func */
/* eslint-disable no-eval */
import { getLazyFactoryID } from "@wix/editor-elements-conventions";
import { createException, RegistryErrorCode } from "../createException";
import { isServer } from "../utils";
const workaround = {};
/**
 * trick to leave `require` as is after webpack build
 * it makes possible to run the same bundle on server and client
 */
eval(
  `workaround.getRequireFunction = () => typeof require !== 'undefined' ? require : undefined`
);
export function getOriginalRequireFunction() {
  return workaround.getRequireFunction();
}
export function isOriginalRequireFunctionAvailable() {
  return typeof getOriginalRequireFunction() !== "undefined";
}
export function getGlobal() {
  return typeof globalThis !== "undefined"
    ? globalThis
    : typeof window !== "undefined"
    ? window
    : typeof self !== "undefined"
    ? self
    : typeof global !== "undefined"
    ? global
    : null;
}
export function requireAMDModule(id) {
  /**
   * This is workaround for webpack...
   * if just use `require` function directly, webpack will transpile it to
   * `__webpack_require__(n)` that always leads to module that throws exception like `module if not defined`
   */
  const localRequire = getOriginalRequireFunction();
  return new Promise((resolve) => {
    /**
     * Trigger `require` to fix `require.specified`
     * https://github.com/requirejs/requirejs/issues/1305#issuecomment-87924865
     **/
    localRequire([]);
    /**
     * To prevent fetching module with `requirejs`
     */
    if (localRequire.specified(id)) {
      localRequire([id], (model) => {
        resolve(model);
      });
    } else {
      resolve(undefined);
    }
  });
}
const parseDefineArguments = (...args) => {
  if (args.length === 3) {
    return {
      id: args[0],
      deps: args[1],
      factory: args[2],
    };
  } else if (args.length === 2) {
    return {
      id: typeof args[0] === "string" ? args[0] : null,
      deps: Array.isArray(args[0]) ? args[0] : [],
      factory: args[1],
    };
  } else {
    return null;
  }
};
function wrapDefineFunction(params) {
  /**
   * If components library was bundled with "umdNamedDefine: true", the UMD header in bundle will be:
   * ...
   * define('bundleId', [], factory)
   * ...
   *
   * If components "umdNamedDefine: false":
   * ...
   * define([], factory)
   * ...
   *
   * So this is anonymous define call, that means that it is not possible to require it after the evaluation
   * Better to track these cases.
   */
  let defineForBundle;
  if (params.define) {
    defineForBundle = (...args) => {
      const parsed = parseDefineArguments(...args);
      if (!parsed) {
        throw new Error("x");
      }
      const { id, deps, factory } = parsed;
      const globals = params.globals;
      const filteredDeps = deps.filter(
        (key) => !globals || (globals && !globals[key])
      );
      if (globals) {
        params.define(id, filteredDeps, (...values) => {
          const allValues = deps.map((dep) => {
            const index = filteredDeps.findIndex((_dep) => _dep === dep);
            if (index === -1) {
              return globals[dep];
            } else {
              return values[index];
            }
          });
          return factory(...allValues);
        });
      } else {
        params.define(...args);
      }
    };
    defineForBundle.amd = params.define.amd;
  }
  return defineForBundle;
}
function getDefineFunction() {
  const currentGlobal = getGlobal();
  return typeof currentGlobal.define === "function" && currentGlobal.define.amd
    ? currentGlobal.define
    : null;
}
export function getEnvironment({ id, globals }) {
  const currentGlobal = getGlobal();
  const _define = getDefineFunction();
  let self = currentGlobal;
  if (globals && !_define) {
    self = new Proxy(currentGlobal, {
      get(target, key) {
        const store = key in globals ? globals : target;
        const value = store[key];
        if (typeof value === "function") {
          const returnValue = (...args) => value.apply(store, args);
          Object.assign(returnValue, value);
          return returnValue;
        } else {
          return value;
        }
      },
    });
  }
  const currentRequire = getOriginalRequireFunction();
  return {
    /**
     * for requirejs environment
     */
    define: wrapDefineFunction({ id, define: _define, globals }),
    /**
     * `workaround.require` – always default require function
     * for SSR – it is node require
     * for CSR – it is requirejs
     */
    require: currentRequire
      ? (name) => {
          if (globals && globals[name]) {
            return globals[name];
          }
          return currentRequire(name);
        }
      : undefined,
    /**
     * always force `module` to be undefine during bundle evaluation
     */
    module: undefined,
    /**
     * commonjs & commonjs2
     *
     * for server env. we provide `exports` as plain object
     * after evaluation, it is possible to get the results:
     * env.exports[bundleId]
     */
    exports:
      isServer() && isOriginalRequireFunctionAvailable() ? {} : undefined,
    /**
     *
     */
    self,
  };
}
export function getGlobalModel(id) {
  const env = getEnvironment({ id });
  const model = env.self[id];
  if (!model && typeof env.define === "function") {
    return requireAMDModule(id);
  }
  return model;
}
export function getModelFromContext(id, context) {
  if (!context) {
    return null;
  }
  const lazyFactoryID = getLazyFactoryID(id);
  const factory = context[lazyFactoryID];
  if (factory && !factory.invoked) {
    factory.invoked = true;
    factory();
  }
  return context[id];
}
export async function getModel(id) {
  const factory = await getGlobalModel(getLazyFactoryID(id));
  if (factory && !factory.invoked) {
    factory.invoked = true;
    factory();
  }
  /**
   * Probably we need to check pending script tags
   */
  return getGlobalModel(id);
}
export function evaluateBundle(
  bundle,
  { id, globals, contexts, useExperimentalEval } = {}
) {
  const env = getEnvironment({ id, globals });
  if (useExperimentalEval) {
    try {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (function ({ define, require, module, exports, self }) {
        eval(`${bundle}
  //# sourceURL=webpack-internal://`);
      })(env);
    } catch (error) {
      throw createException(RegistryErrorCode.Unknown);
    }
  } else {
    const evaluateBundleSources = new Function(
      "define",
      "require",
      "module",
      "exports",
      "self",
      bundle
    );
    evaluateBundleSources(
      env.define,
      env.require,
      env.module,
      env.exports,
      env.self
    );
  }
  if (!id) {
    return;
  }
  if (typeof env.exports === "object") {
    contexts[id] = env.exports;
  }
}
//# sourceMappingURL=evaluateBundle.js.map

// @ts-nocheck
import { getImageSrc } from "./utils";
import ImageLoader from "./ImageLoader";
import imageLayout from "./imageLayout";
const TIMEOUT = 250;
function wowImageFactory(services, environmentConsts, contextWindow) {
  var _a;
  const relayoutOnIntersect =
    (_a = services.isExperimentOpen) === null || _a === void 0
      ? void 0
      : _a.call(services, "specs.thunderbolt.wowImageRelayout");
  // remove imageLoader on experiment merge
  if (!services.imageLoader && !relayoutOnIntersect) {
    services.imageLoader = new ImageLoader(services.mutationService);
  }
  return class WowImage extends contextWindow.HTMLElement {
    constructor() {
      // eslint-disable-line no-useless-constructor
      super();
      this.childListObserver = null;
      this.timeoutId = null;
    }
    attributeChangedCallback(_, oldValue) {
      if (oldValue) {
        this.reLayout();
      }
    }
    connectedCallback() {
      if (relayoutOnIntersect) {
        if (environmentConsts.disableImagesLazyLoading) {
          this.reLayout();
        } else {
          this.observeIntersect();
        }
      } else {
        // remove reLayout and observeResize calls on experiment merge
        this.observeResize();
        this.reLayout();
      }
    }
    disconnectedCallback() {
      this.unobserveResize();
      this.unobserveIntersect();
      !relayoutOnIntersect && services.imageLoader.onImageDisconnected(this);
      this.unobserveChildren();
    }
    static get observedAttributes() {
      return ["data-image-info"];
    }
    reLayout() {
      const domNodes = {};
      const measures = {};
      const imageId = this.getAttribute("id");
      const imageInfo = JSON.parse(this.dataset.imageInfo || "");
      // const isResponsive = this.dataset.isResponsive === 'true';
      const { bgEffectName } = this.dataset;
      domNodes[imageId] = this;
      if (imageInfo.containerId) {
        domNodes[imageInfo.containerId] = contextWindow.document.getElementById(
          `${imageInfo.containerId}`
        );
      }
      domNodes.image = this.querySelector("img");
      // domNodes.picture = this.querySelector('picture');
      const containerElm = imageInfo.containerId
        ? domNodes[imageInfo.containerId]
        : undefined;
      if (!domNodes.image) {
        // missing children, can't layout, wait for children to be created first
        const target = this;
        this.observeChildren(target);
        return;
      }
      // clean up
      this.unobserveChildren();
      // from now on just observe changes to children of top level
      this.observeChildren(this);
      services.mutationService.measure(() => {
        // if (isResponsive) {
        //   imageLayoutResponsive.measure(
        //     imageId,
        //     measures as WixImageXMeasures,
        //     domNodes,
        //     services,
        //   );
        // } else {
        imageLayout.measure(
          imageId,
          measures,
          domNodes,
          {
            containerElm,
            bgEffectName,
          },
          services
        );
      });
      const patchImage = (shouldLoadImage) => {
        services.mutationService.mutate(() => {
          // if (isResponsive) {
          //   imageLayoutResponsive.patch(
          //     imageId,
          //     measures as WixImageXMeasures,
          //     domNodes,
          //     imageInfo,
          //     services,
          //     environmentConsts,
          //     shouldLoadImage,
          //   );
          // } else {
          imageLayout.patch(
            imageId,
            measures,
            domNodes,
            imageInfo,
            services,
            environmentConsts,
            shouldLoadImage,
            bgEffectName
          );
        });
      };
      // if image has no src or current src if from ssr render stage  -
      // load the image immediately, otherwise - debounce the reload
      if (!getImageSrc(domNodes.image) || this.dataset.hasSsrSrc) {
        patchImage(true);
      } else {
        this.debounceImageLoad(patchImage);
      }
    }
    /**
     * Debounce consecutive image loads
     *
     * @param {function} patchImage closure for patching the image
     */
    debounceImageLoad(patchImage) {
      clearTimeout(this.timeoutId);
      this.timeoutId = contextWindow.setTimeout(() => {
        patchImage(true);
      }, TIMEOUT);
      patchImage(false);
    }
    observeResize() {
      var _a;
      (_a = services.resizeService) === null || _a === void 0
        ? void 0
        : _a.observe(this);
    }
    unobserveResize() {
      var _a;
      (_a = services.resizeService) === null || _a === void 0
        ? void 0
        : _a.unobserve(this);
    }
    observeIntersect() {
      var _a;
      (_a = services.intersectionService) === null || _a === void 0
        ? void 0
        : _a.observe(this);
    }
    unobserveIntersect() {
      var _a;
      (_a = services.intersectionService) === null || _a === void 0
        ? void 0
        : _a.unobserve(this);
    }
    /**
     * Observe DOM mutations to wait for addition of missing children
     *
     * @param {HTMLElement} parent
     */
    observeChildren(parent) {
      if (!this.childListObserver) {
        this.childListObserver = new contextWindow.MutationObserver(() => {
          this.reLayout();
        });
      }
      this.childListObserver.observe(parent, { childList: true });
    }
    /**
     * Remove DOM MutationObserver if one was created
     */
    unobserveChildren() {
      if (this.childListObserver) {
        this.childListObserver.disconnect();
        this.childListObserver = null;
      }
    }
  };
}
export default wowImageFactory;
//# sourceMappingURL=WowImage.js.map
